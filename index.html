<!DOCTYPE html>
<html lang="en">
  <head>
    <base href="http://192.168.0.5:2222/">
    <meta charset="UTF-8">
    <title>Blackfisk</title>
    <style data-savepage-href="./style.css">
      
      canvas {
      opaticy: 0.8;
      }
      
      html, body {
      filter: blur(1.5rem);
        background: #f2f2f2;
        background: -moz-radial-gradient(center, ellipse cover,  #ffffff 0%, #ffffff 26%, #f5f5f5 59%, #f5f5f5 77%, #cecece 100%);
        background: -webkit-gradient(radial, center center, 0, center center, 100%, color-stop(0%,#ffffff), color-stop(26%,#ffffff), color-stop(59%,#f5f5f5), color-stop(77%,#f5f5f5), color-stop(100%,#cecece));
        background: -webkit-radial-gradient(center, ellipse cover,  #ffffff 0%,#ffffff 26%,#f5f5f5 59%,#f5f5f5 77%,#cecece 100%);
        background: -o-radial-gradient(center, ellipse cover,  #ffffff 0%,#ffffff 26%,#f5f5f5 59%,#f5f5f5 77%,#cecece 100%);
        background: -ms-radial-gradient(center, ellipse cover,  #ffffff 0%,#ffffff 26%,#f5f5f5 59%,#f5f5f5 77%,#cecece 100%);
        background: radial-gradient(ellipse at center,  #ffffff 0%,#ffffff 26%,#f5f5f5 59%,#f5f5f5 77%,#cecece 100%);
        overflow: hidden;
        padding: 0;
        margin: 0;
        height: 100%;
      }

      body:before {

        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDRCNjE4NDcxMDgzMTFFMkFGQkM4MzE4NzI4RjhBMkQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDRCNjE4NDgxMDgzMTFFMkFGQkM4MzE4NzI4RjhBMkQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpENEI2MTg0NTEwODMxMUUyQUZCQzgzMTg3MjhGOEEyRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpENEI2MTg0NjEwODMxMUUyQUZCQzgzMTg3MjhGOEEyRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pp/mixwAABMrSURBVHjaNNrnrptV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);
        pointer-events: none;
        position: absolute;
        content: '';
        height: 100%;
        width: 100%;
        left: 0;
        top: 0;
      }

      html.dark, body.dark {
        background: #283442;
        background: -moz-radial-gradient(center, ellipse cover,  #283442 0%, #122335 40%, #000d19 100%);
        background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%,#283442), color-stop(40%,#122335), color-stop(100%,#000d19));
        background: -webkit-radial-gradient(center, ellipse cover,  #283442 0%,#122335 40%,#000d19 100%);
        background: -o-radial-gradient(center, ellipse cover,  #283442 0%,#122335 40%,#000d19 100%);
        background: -ms-radial-gradient(center, ellipse cover,  #283442 0%,#122335 40%,#000d19 100%);
        background: radial-gradient(ellipse at center,  #283442 0%,#122335 40%,#000d19 100%);
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#283442', endColorstr='#000d19',GradientType=1 );
      }

      #container {
        cursor: pointer;
      }

      /* Info */

      @-webkit-keyframes show-info {
        0% { -webkit-transform: rotateY(120deg); }
        100% { -webkit-transform: rotateY(0deg); }
      }

      @-moz-keyframes show-info {
        0% { -moz-transform: rotateY(120deg); }
        100% { -moz-transform: rotateY(0deg); }
      }

      @-ms-keyframes show-info {
        0% { -ms-transform: rotateY(120deg); }
        100% { -ms-transform: rotateY(0deg); }
      }

      @-o-keyframes show-info {
        0% { -o-transform: rotateY(120deg); }
        100% { -o-transform: rotateY(0deg); }
      }

      @keyframes show-info {
        0% { transform: rotateY(120deg); }
        100% { transform: rotateY(0deg); }
      }

      .info {

        -webkit-transition: all 180ms ease-out;
        -moz-transition: all 180ms ease-out;
        -ms-transition: all 180ms ease-out;
        -o-transition: all 180ms ease-out;
        transition: all 180ms ease-out;

        -webkit-transform-style: preserve-3d;
        -moz-transform-style: preserve-3d;
        -ms-transform-style: preserve-3d;
        -o-transform-style: preserve-3d;
        transform-style: preserve-3d;

        -webkit-transform: perspective(800);
        -moz-transform: perspective(800);
        -ms-transform: perspective(800);
        -o-transform: perspective(800);
        transform: perspective(800);

        font-family: 'Quantico', sans-serif;
        position: absolute;
        font-size: 12px;
        opacity: 0.85;
        color: #fff;
        width: 240px;
        left: 0px;
        top: 20px;
      }

      .info:hover {

        box-shadow: 0 0 0 4px rgba(0,0,0,0.1);
        opacity: 1.0;
      }

      .info h1,
      .info h2,
      .info h3 {

        line-height: 1;
        margin: 5px 0;
      }

      .info .about, .info .more {

        -webkit-transform-origin: 0% 50%;
        -moz-transform-origin: 0% 50%;
        -ms-transform-origin: 0% 50%;
        -o-transform-origin: 0% 50%;
        transform-origin: 0% 50%;

        -webkit-transform: rotateY(120deg);
        -moz-transform: rotateY(120deg);
        -ms-transform: rotateY(120deg);
        -o-transform: rotateY(120deg);
        transform: rotateY(120deg);

        margin-bottom: 1px;
        background: rgba(0,0,0,0.95);
        padding: 12px 15px 12px 20px;
      }

      .info .about {

        -webkit-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;
        -moz-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;
        -ms-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;
        -o-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;
        animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;

        padding-bottom: 15px;
      }

      .info .about h1 {

        letter-spacing: -1px;
        font-weight: 300;
        font-size: 19px;
        opacity: 0.95;
      }

      .info .about h2 {

        font-weight: 300;
        font-size: 13px;
        opacity: 0.8;
      }

      .info .about h3 {

        text-transform: uppercase;
        margin-top: 10px;
        font-size: 11px;
      }

      .info .about h3:after {

        margin-left: 4px;
        font-size: 14px;
        content: '\203A';
      }

      .info .more {

        -webkit-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;
        -moz-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;
        -ms-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;
        -o-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;
        animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;

        padding: 5px 15px 10px 20px;
      }

      .info .more a {

        -webkit-transition: all 200ms ease-out;
        -moz-transition: all 200ms ease-out;
        -ms-transition: all 200ms ease-out;
        -o-transition: all 200ms ease-out;
        transition: all 200ms ease-out;

        border-bottom: 1px dotted rgba(255,255,255,0.4);
        text-transform: uppercase;
        text-decoration: none;
        margin-right: 10px;
        font-size: 10px;
        opacity: 0.6;
        color: #fff;
      }

      .info .more a:hover {

        opacity: 0.99;
      }
    </style>
    <style>


      html, body {

        background: #f2f2f2;
        background: -moz-radial-gradient(center, ellipse cover,  #ffffff 0%, #ffffff 26%, #f5f5f5 59%, #f5f5f5 77%, #cecece 100%);
        background: -webkit-gradient(radial, center center, 0, center center, 100%, color-stop(0%,#ffffff), color-stop(26%,#ffffff), color-stop(59%,#f5f5f5), color-stop(77%,#f5f5f5), color-stop(100%,#cecece));
        background: -webkit-radial-gradient(center, ellipse cover,  #ffffff 0%,#ffffff 26%,#f5f5f5 59%,#f5f5f5 77%,#cecece 100%);
        background: -o-radial-gradient(center, ellipse cover,  #ffffff 0%,#ffffff 26%,#f5f5f5 59%,#f5f5f5 77%,#cecece 100%);
        background: -ms-radial-gradient(center, ellipse cover,  #ffffff 0%,#ffffff 26%,#f5f5f5 59%,#f5f5f5 77%,#cecece 100%);
        background: radial-gradient(ellipse at center,  #ffffff 0%,#ffffff 26%,#f5f5f5 59%,#f5f5f5 77%,#cecece 100%);
        overflow: hidden;
        padding: 0;
        margin: 0;
        height: 100%;
      }

      body:before {
      pointer-events: none;
        position: absolute;
        content: '';
        height: 100%;
        width: 100%;
        left: 0;
        top: 0;
      }

      html.dark, body.dark {
        background: #283442;
        background: -moz-radial-gradient(center, ellipse cover,  #283442 0%, #122335 40%, #000d19 100%);
        background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%,#283442), color-stop(40%,#122335), color-stop(100%,#000d19));
        background: -webkit-radial-gradient(center, ellipse cover,  #283442 0%,#122335 40%,#000d19 100%);
        background: -o-radial-gradient(center, ellipse cover,  #283442 0%,#122335 40%,#000d19 100%);
        background: -ms-radial-gradient(center, ellipse cover,  #283442 0%,#122335 40%,#000d19 100%);
        background: radial-gradient(ellipse at center,  #283442 0%,#122335 40%,#000d19 100%);
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#283442', endColorstr='#000d19',GradientType=1 );
      }

      #container {
        cursor: pointer;
      }

      /* Info */

      @-webkit-keyframes show-info {
        0% { -webkit-transform: rotateY(120deg); }
        100% { -webkit-transform: rotateY(0deg); }
      }

      @-moz-keyframes show-info {
        0% { -moz-transform: rotateY(120deg); }
        100% { -moz-transform: rotateY(0deg); }
      }

      @-ms-keyframes show-info {
        0% { -ms-transform: rotateY(120deg); }
        100% { -ms-transform: rotateY(0deg); }
      }

      @-o-keyframes show-info {
        0% { -o-transform: rotateY(120deg); }
        100% { -o-transform: rotateY(0deg); }
      }

      @keyframes show-info {
        0% { transform: rotateY(120deg); }
        100% { transform: rotateY(0deg); }
      }

      .info {

        -webkit-transition: all 180ms ease-out;
        -moz-transition: all 180ms ease-out;
        -ms-transition: all 180ms ease-out;
        -o-transition: all 180ms ease-out;
        transition: all 180ms ease-out;

        -webkit-transform-style: preserve-3d;
        -moz-transform-style: preserve-3d;
        -ms-transform-style: preserve-3d;
        -o-transform-style: preserve-3d;
        transform-style: preserve-3d;

        -webkit-transform: perspective(800);
        -moz-transform: perspective(800);
        -ms-transform: perspective(800);
        -o-transform: perspective(800);
        transform: perspective(800);

        font-family: 'Quantico', sans-serif;
        position: absolute;
        font-size: 12px;
        opacity: 0.85;
        color: #fff;
        width: 240px;
        left: 0px;
        top: 20px;
      }

      .info:hover {

        box-shadow: 0 0 0 4px rgba(0,0,0,0.1);
        opacity: 1.0;
      }

      .info h1,
      .info h2,
      .info h3 {

        line-height: 1;
        margin: 5px 0;
      }

      .info .about, .info .more {

        -webkit-transform-origin: 0% 50%;
        -moz-transform-origin: 0% 50%;
        -ms-transform-origin: 0% 50%;
        -o-transform-origin: 0% 50%;
        transform-origin: 0% 50%;

        -webkit-transform: rotateY(120deg);
        -moz-transform: rotateY(120deg);
        -ms-transform: rotateY(120deg);
        -o-transform: rotateY(120deg);
        transform: rotateY(120deg);

        margin-bottom: 1px;
        background: rgba(0,0,0,0.95);
        padding: 12px 15px 12px 20px;
      }

      .info .about {

        -webkit-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;
        -moz-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;
        -ms-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;
        -o-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;
        animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 600ms 1 normal forwards;

        padding-bottom: 15px;
      }

      .info .about h1 {

        letter-spacing: -1px;
        font-weight: 300;
        font-size: 19px;
        opacity: 0.95;
      }

      .info .about h2 {

        font-weight: 300;
        font-size: 13px;
        opacity: 0.8;
      }

      .info .about h3 {

        text-transform: uppercase;
        margin-top: 10px;
        font-size: 11px;
      }

      .info .about h3:after {

        margin-left: 4px;
        font-size: 14px;
        content: '\203A';
      }

      .info .more {

        -webkit-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;
        -moz-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;
        -ms-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;
        -o-animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;
        animation: show-info 500ms cubic-bezier(0.230, 1.000, 0.320, 1.000) 500ms 1 normal forwards;

        padding: 5px 15px 10px 20px;
      }

      .info .more a {

        -webkit-transition: all 200ms ease-out;
        -moz-transition: all 200ms ease-out;
        -ms-transition: all 200ms ease-out;
        -o-transition: all 200ms ease-out;
        transition: all 200ms ease-out;

        border-bottom: 1px dotted rgba(255,255,255,0.4);
        text-transform: uppercase;
        text-decoration: none;
        margin-right: 10px;
        font-size: 10px;
        opacity: 0.6;
        color: #fff;
      }

      .info .more a:hover {

        opacity: 0.99;
      }
    </style>
    <link rel="icon" href="">
    <script id="savepage-contentloaders" type="application/javascript">
      "use strict"
      savepage_ContentLoaders();
      function savepage_ContentLoaders()
      {
        var resourceMimeType = new Array();
        var resourceBase64Data = new Array();
        var resourceBlobUrl = new Array();
        window.addEventListener("DOMContentLoaded",
        function(event)
        {
          savepage_ShadowLoader(8);
          savepage_ResourceLoader(8);
          document.getElementById('savepage-contentloaders').remove();
        },false);
        function savepage_ShadowLoader(c){createShadowDOMs(0,document.documentElement);function createShadowDOMs(a,b){var i;if(b.localName=="iframe"||b.localName=="frame"){if(a<c){try{if(b.contentDocument.documentElement!=null){createShadowDOMs(a+1,b.contentDocument.documentElement)}}catch(e){}}}else{if(b.children.length>=1&&b.children[0].localName=="template"&&b.children[0].hasAttribute("data-savepage-shadowroot")){b.attachShadow({mode:"open"}).appendChild(b.children[0].content);b.removeChild(b.children[0]);for(i=0;i<b.shadowRoot.children.length;i++)if(b.shadowRoot.children[i]!=null)createShadowDOMs(a,b.shadowRoot.children[i])}for(i=0;i<b.children.length;i++)if(b.children[i]!=null)createShadowDOMs(a,b.children[i])}}}
        function savepage_ResourceLoader(f){createBlobURLs();replaceReferences(0,document.documentElement);function createBlobURLs(){var i,j,binaryString,blobData;var a=new Array();for(i=0;i<resourceMimeType.length;i++){if(typeof resourceMimeType[i]!="undefined"){binaryString=atob(resourceBase64Data[i]);resourceBase64Data[i]="";a.length=0;for(j=0;j<binaryString.length;j++){a[j]=binaryString.charCodeAt(j)}blobData=new Blob([new Uint8Array(a)],{type:resourceMimeType[i]});resourceMimeType[i]="";resourceBlobUrl[i]=window.URL.createObjectURL(blobData)}}}function replaceReferences(a,b){var i,regex1,regex2,csstext,blobData;regex1=/url\(\s*((?:"[^"]+")|(?:'[^']+')|(?:[^\s)]+))\s*\)/gi;regex2=/data:[^;]*;resource=(\d+);base64,/i;if(b.hasAttribute("style")){csstext=b.style.cssText;b.style.cssText=csstext.replace(regex1,replaceCSSRef)}if(b.localName=="style"){csstext=b.textContent;b.textContent=csstext.replace(regex1,replaceCSSRef)}else if(b.localName=="link"&&(b.rel.toLowerCase()=="icon"||b.rel.toLowerCase()=="shortcut icon")){if(b.href!="")b.href=b.href.replace(regex2,replaceRef)}else if(b.localName=="body"){if(b.background!="")b.background=b.background.replace(regex2,replaceRef)}else if(b.localName=="img"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}else if(b.localName=="input"&&b.type.toLowerCase()=="image"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}else if(b.localName=="audio"){if(b.src!=""){b.src=b.src.replace(regex2,replaceRef);b.load()}}else if(b.localName=="video"){if(b.src!=""){b.src=b.src.replace(regex2,replaceRef);b.load()}if(b.poster!="")b.poster=b.poster.replace(regex2,replaceRef)}else if(b.localName=="source"){if(b.src!=""){b.src=b.src.replace(regex2,replaceRef);b.parentElement.load()}}else if(b.localName=="track"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}else if(b.localName=="object"){if(b.data!="")b.data=b.data.replace(regex2,replaceRef)}else if(b.localName=="embed"){if(b.src!="")b.src=b.src.replace(regex2,replaceRef)}if(b.localName=="iframe"||b.localName=="frame"){if(a<f){if(b.hasAttribute("data-savepage-sameorigin")){blobData=new Blob([decodeURIComponent(b.src.substr(29))],{type:"text/html;charset=utf-8"});b.onload=function(){try{if(b.contentDocument.documentElement!=null){replaceReferences(a+1,b.contentDocument.documentElement)}}catch(e){}};b.src=window.URL.createObjectURL(blobData)}}}else{if(b.shadowRoot!=null){for(i=0;i<b.shadowRoot.children.length;i++)if(b.shadowRoot.children[i]!=null)replaceReferences(a,b.shadowRoot.children[i])}for(i=0;i<b.children.length;i++)if(b.children[i]!=null)replaceReferences(a,b.children[i])}}function replaceCSSRef(a,b,c,d){var e=new Array();e=b.match(/data:[^;]*;resource=(\d+);base64,/i);if(e!=null)return"url("+resourceBlobUrl[+e[1]]+")";else return a}function replaceRef(a,b,c,d){return resourceBlobUrl[+b]}}
      }
    </script>
    <meta name="savepage-url" content="http://192.168.0.5:2222/">
    <meta name="savepage-title" content="Blackfisk">
    <meta name="savepage-date" content="Sat Jul 13 2019 15:52:22 GMT+0200 (Central European Summer Time)">
    <meta name="savepage-state" content="Custom Items; HTML image files (all); HTML audio & video files; HTML object & embed files; CSS image files (all); CSS font files (all); Scripts (in same-origin frames); Used resource loader; Retained cross-origin frames; Removed unsaved URLs; Allowed passive mixed content; Sent referer headers with origin and path; Max frame depth = 8; Max resource size = 250MB; Max resource time = 22s;">
    <meta name="savepage-version" content="15.1">
    <meta name="savepage-comments" content="">
    <meta name="savepage-resourceloader" content="">
  </head>
  <body>
    <div id="container" style="background-image: url(data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCATTA2cDASIAAhEBAxEB/8QAHgABAAEFAQEBAQAAAAAAAAAAAAcDBAUGCAIBCQr/xABSEAABAwMDAgQEAwUFBwEFAg8BAgMEAAURBhIhBzETIkFRCBRhcTJCgRUjUpGhFmJysfAkM0OCwdHhkgkXJTRTovE1Y7JzGCZEVIOTo8JFVcP/xAAcAQEAAgMBAQEAAAAAAAAAAAAAAwQBAgUGBwj/xAA+EQACAQMDAgMGBQQBBAEDBQAAAQIDBBESITEFQRNRYQYicYGR8DKhscHRFCNC4fEHFTNSJFNichY0krLC/9oADAMBAAIRAxEAPwD9HaUpXCOwKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUqk9LjxxuddSn7msN4MpOTwirSsHL1VDZylkFw1iJOqZzuQ0A2KjlWjEvUum3FXfGPibkpaEjKlAVRcnw2v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pSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlKAUpSgFKUoBSlaoOpmmDbdRXdK5JiaYe8Cc74WElfhpc8hJwobHEHOeNwz60MqLlwbXStFkdZ9FR2XZAcnutw4Ma43BTURShb2H+Gy97KJzlCdyxtVxgZrNsa601LnKgQZq5Sm5bcF1yO0pxDT7jQdQhZSDtBQpJ3fh5AJB4rBs6c1yjP1irnqmw2e8WqwXGf4U+9uONQWQ0tZdUhCnFDKQQnCUKOVEDynFR1bOoeg9LN37VrF5vt2cvV+NuZgeGha3JSClvwYrY2hQysAqUc8YJ8vGNl6ntNy6xnVt+W5bLTobTz0p8yUbSy9IWWxvAzlSUszB5cgjBBIOSySKi8vPH7/8AJNlK04dWdGM26RcrtLk2luNETPU3OjLbeXHISQ4hsAqV+JIKQN4KgCkEivVx6raLs0WZJvc6Rb1QWG5DseRFcD5Q5jYEoAJUo5A2DzAkAgEihH4c/I2+lanJ6oaUt1ru90vD8m3fsFhEq4RpLChIYZWkqQvw05KgQlZG3P4VDuCBTX1a0IxcXrbLu7kVbEF64qckRnW2iw1s8QhakgKKfFb4HfdxnBwHhz8jcKVp73VnQ8KJ89drm7bGTbVXhBnRnGVOQ0kAuBJG7IJHkIC+QdvNW7/VjTJgXMuPybXMhQ0yg1PY8JZQ4E+GsA/VaMpOFJyNwFB4c32N4rEw9V6fuF/maXhXFL1zgMpfksJQr90hSilJKsbeSlQxnPlV7Go10b1fuUDSenE65t1xN2vsMTWJckMNsvLdQ9IbZPg5UhQZaWB+7HKADgqGfHw6MXW7t6p6j3VuNu1PdVtsuNOFQWzEywkpyB5FOB9YPH4+wpkkdFxjJy7fmTHSlKyQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAUpQeVFeTHcSh0tqCFK7JVjgn9a5zvViuSdH2Xpou4wZcrVd9mFbtsdW42+xJfdU64pSkpyhMNb4GMpBYHmPGOhL5aIeobLcLBcfE+VuUV2G/4ayhfhuIKFbVDkHBOD6VjLboiy2++J1I4XplxZiiFGekFP8As0fjLbSUJSlAJAJOMntnHFYJqVRU1k0O19GnoGpNTquFqtN2tGopjU5LkiY+lTZQyGfDdjJT4byQAVcqGd6gcDFV3+ld+mX5GqAq32m9IEhiXLtr7jbVxjKQ4lptxopO3lTZOVLCSklOSrNSrSmB48+SCtJdENb6YVom4rk6fmTdOyZb89pb7yW31v8AzRL6F+ESV7pRISUgAJxuOQRfy+jWrrlC1Om63W0Spd8u1tnlY8RCJDMUNBbKxtPhJcKXiQN/++I9MmZqUwZdxNvP3zkhTWHRXV+sdQydcS7pamLmy7FNutoW4uKEMyWH1eK8UbtznyrCTtRhICvxbsjbtX6Hu+qXbRdf2fZo8y3XWLPfYDylJlIaUlWFPeEFEpKUlIKCMoHI9N9pTBjxpbehB+oOh2r9V3C4XO83e2tr1FMhoujcd50fK25h1aywyvYC6tYedSVKDYAKMDg5q636I6m1fddSyROtDDE61N260kqcywgLWpba2wjCUqAjAlJOQxjb5twmulMGVcTXH394I06n9OL11O0XItE2BY4F0UqO6Ch9x1DxbXvLK3fDQsNqIwcJJwT2rUermmJr2nRp2BabbbdR65ktWtbqZjswkL3eKHHlpSsoS0p9YSEgAtEjk8TzWEnaQtlx1VbtWy3ZK5VqbWiKzuT4KFKStJcxjJXtcWnOcAKPHNBTrOOM8I0LU3SjU+spsSddrha7emxR202iLA8Qo+YDewuuqWBgJSt5KEAHG8EkkYrZukekr5oXQlp0je3bcpVpioiN/JbylYTnLiioDzKPJSBgHPKu9blShpKrKUdD4FKUrJGKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQClKUApSlAKUpQH/9k=);">




    </div>
    <script>
        /*!
       * jQuery JavaScript Library v3.4.1
       * https://jquery.com/
       *
       * Includes Sizzle.js
       * https://sizzlejs.com/
       *
       * Copyright JS Foundation and other contributors
       * Released under the MIT license
       * https://jquery.org/license
       *
       * Date: 2019-05-01T21:04Z
       */
      ( function( global, factory ) {

        "use strict";

        if ( typeof module === "object" && typeof module.exports === "object" ) {

          // For CommonJS and CommonJS-like environments where a proper `window`
          // is present, execute the factory and get jQuery.
          // For environments that do not have a `window` with a `document`
          // (such as Node.js), expose a factory as module.exports.
          // This accentuates the need for the creation of a real `window`.
          // e.g. var jQuery = require("jquery")(window);
          // See ticket #14549 for more info.
          module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
              if ( !w.document ) {
                throw new Error( "jQuery requires a window with a document" );
              }
              return factory( w );
            };
        } else {
          factory( global );
        }

      // Pass this if window is not defined yet
      } )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

      // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
      // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
      // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
      // enough that all such attempts are guarded in a try block.
      "use strict";

      var arr = [];

      var document = window.document;

      var getProto = Object.getPrototypeOf;

      var slice = arr.slice;

      var concat = arr.concat;

      var push = arr.push;

      var indexOf = arr.indexOf;

      var class2type = {};

      var toString = class2type.toString;

      var hasOwn = class2type.hasOwnProperty;

      var fnToString = hasOwn.toString;

      var ObjectFunctionString = fnToString.call( Object );

      var support = {};

      var isFunction = function isFunction( obj ) {

            // Support: Chrome <=57, Firefox <=52
            // In some browsers, typeof returns "function" for HTML <object> elements
            // (i.e., `typeof document.createElement( "object" ) === "function"`).
            // We don't want to classify *any* DOM node as a function.
            return typeof obj === "function" && typeof obj.nodeType !== "number";
        };


      var isWindow = function isWindow( obj ) {
          return obj != null && obj === obj.window;
        };




        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };

        function DOMEval( code, node, doc ) {
          doc = doc || document;

          var i, val,
            script = doc.createElement( "script" );

          script.text = code;
          if ( node ) {
            for ( i in preservedScriptAttributes ) {

              // Support: Firefox 64+, Edge 18+
              // Some browsers don't support the "nonce" property on scripts.
              // On the other hand, just using `getAttribute` is not enough as
              // the `nonce` attribute is reset to an empty string whenever it
              // becomes browsing-context connected.
              // See https://github.com/whatwg/html/issues/2369
              // See https://html.spec.whatwg.org/#nonce-attributes
              // The `node.getAttribute` check was added for the sake of
              // `jQuery.globalEval` so that it can fake a nonce-containing node
              // via an object.
              val = node[ i ] || node.getAttribute && node.getAttribute( i );
              if ( val ) {
                script.setAttribute( i, val );
              }
            }
          }
          doc.head.appendChild( script ).parentNode.removeChild( script );
        }


      function toType( obj ) {
        if ( obj == null ) {
          return obj + "";
        }

        // Support: Android <=2.3 only (functionish RegExp)
        return typeof obj === "object" || typeof obj === "function" ?
          class2type[ toString.call( obj ) ] || "object" :
          typeof obj;
      }
      /* global Symbol */
      // Defining this global in .eslintrc.json would create a danger of using the global
      // unguarded in another place, it seems safer to define global only for this module



      var
        version = "3.4.1",

        // Define a local copy of jQuery
        jQuery = function( selector, context ) {

          // The jQuery object is actually just the init constructor 'enhanced'
          // Need init if jQuery is called (just allow error to be thrown if not included)
          return new jQuery.fn.init( selector, context );
        },

        // Support: Android <=4.0 only
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

      jQuery.fn = jQuery.prototype = {

        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function() {
          return slice.call( this );
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function( num ) {

          // Return all the elements in a clean array
          if ( num == null ) {
            return slice.call( this );
          }

          // Return just the one element from the set
          return num < 0 ? this[ num + this.length ] : this[ num ];
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function( elems ) {

          // Build a new jQuery matched element set
          var ret = jQuery.merge( this.constructor(), elems );

          // Add the old object onto the stack (as a reference)
          ret.prevObject = this;

          // Return the newly-formed element set
          return ret;
        },

        // Execute a callback for every element in the matched set.
        each: function( callback ) {
          return jQuery.each( this, callback );
        },

        map: function( callback ) {
          return this.pushStack( jQuery.map( this, function( elem, i ) {
            return callback.call( elem, i, elem );
          } ) );
        },

        slice: function() {
          return this.pushStack( slice.apply( this, arguments ) );
        },

        first: function() {
          return this.eq( 0 );
        },

        last: function() {
          return this.eq( -1 );
        },

        eq: function( i ) {
          var len = this.length,
            j = +i + ( i < 0 ? len : 0 );
          return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
        },

        end: function() {
          return this.prevObject || this.constructor();
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
      };

      jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
          target = arguments[ 0 ] || {},
          i = 1,
          length = arguments.length,
          deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
          deep = target;

          // Skip the boolean and the target
          target = arguments[ i ] || {};
          i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !isFunction( target ) ) {
          target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
          target = this;
          i--;
        }

        for ( ; i < length; i++ ) {

          // Only deal with non-null/undefined values
          if ( ( options = arguments[ i ] ) != null ) {

            // Extend the base object
            for ( name in options ) {
              copy = options[ name ];

              // Prevent Object.prototype pollution
              // Prevent never-ending loop
              if ( name === "__proto__" || target === copy ) {
                continue;
              }

              // Recurse if we're merging plain objects or arrays
              if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                ( copyIsArray = Array.isArray( copy ) ) ) ) {
                src = target[ name ];

                // Ensure proper type for the source value
                if ( copyIsArray && !Array.isArray( src ) ) {
                  clone = [];
                } else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
                  clone = {};
                } else {
                  clone = src;
                }
                copyIsArray = false;

                // Never move original objects, clone them
                target[ name ] = jQuery.extend( deep, clone, copy );

              // Don't bring in undefined values
              } else if ( copy !== undefined ) {
                target[ name ] = copy;
              }
            }
          }
        }

        // Return the modified object
        return target;
      };

      jQuery.extend( {

        // Unique for each copy of jQuery on the page
        expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function( msg ) {
          throw new Error( msg );
        },

        noop: function() {},

        isPlainObject: function( obj ) {
          var proto, Ctor;

          // Detect obvious negatives
          // Use toString instead of jQuery.type to catch host objects
          if ( !obj || toString.call( obj ) !== "[object Object]" ) {
            return false;
          }

          proto = getProto( obj );

          // Objects with no prototype (e.g., `Object.create( null )`) are plain
          if ( !proto ) {
            return true;
          }

          // Objects with prototype are plain iff they were constructed by a global Object function
          Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
          return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
        },

        isEmptyObject: function( obj ) {
          var name;

          for ( name in obj ) {
            return false;
          }
          return true;
        },

        // Evaluates a script in a global context
        globalEval: function( code, options ) {
          DOMEval( code, { nonce: options && options.nonce } );
        },

        each: function( obj, callback ) {
          var length, i = 0;

          if ( isArrayLike( obj ) ) {
            length = obj.length;
            for ( ; i < length; i++ ) {
              if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                break;
              }
            }
          } else {
            for ( i in obj ) {
              if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                break;
              }
            }
          }

          return obj;
        },

        // Support: Android <=4.0 only
        trim: function( text ) {
          return text == null ?
            "" :
            ( text + "" ).replace( rtrim, "" );
        },

        // results is for internal usage only
        makeArray: function( arr, results ) {
          var ret = results || [];

          if ( arr != null ) {
            if ( isArrayLike( Object( arr ) ) ) {
              jQuery.merge( ret,
                typeof arr === "string" ?
                [ arr ] : arr
              );
            } else {
              push.call( ret, arr );
            }
          }

          return ret;
        },

        inArray: function( elem, arr, i ) {
          return arr == null ? -1 : indexOf.call( arr, elem, i );
        },

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function( first, second ) {
          var len = +second.length,
            j = 0,
            i = first.length;

          for ( ; j < len; j++ ) {
            first[ i++ ] = second[ j ];
          }

          first.length = i;

          return first;
        },

        grep: function( elems, callback, invert ) {
          var callbackInverse,
            matches = [],
            i = 0,
            length = elems.length,
            callbackExpect = !invert;

          // Go through the array, only saving the items
          // that pass the validator function
          for ( ; i < length; i++ ) {
            callbackInverse = !callback( elems[ i ], i );
            if ( callbackInverse !== callbackExpect ) {
              matches.push( elems[ i ] );
            }
          }

          return matches;
        },

        // arg is for internal usage only
        map: function( elems, callback, arg ) {
          var length, value,
            i = 0,
            ret = [];

          // Go through the array, translating each of the items to their new values
          if ( isArrayLike( elems ) ) {
            length = elems.length;
            for ( ; i < length; i++ ) {
              value = callback( elems[ i ], i, arg );

              if ( value != null ) {
                ret.push( value );
              }
            }

          // Go through every key on the object,
          } else {
            for ( i in elems ) {
              value = callback( elems[ i ], i, arg );

              if ( value != null ) {
                ret.push( value );
              }
            }
          }

          // Flatten any nested arrays
          return concat.apply( [], ret );
        },

        // A global GUID counter for objects
        guid: 1,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
      } );

      if ( typeof Symbol === "function" ) {
        jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
      }

      // Populate the class2type map
      jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
      function( i, name ) {
        class2type[ "[object " + name + "]" ] = name.toLowerCase();
      } );

      function isArrayLike( obj ) {

        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
          type = toType( obj );

        if ( isFunction( obj ) || isWindow( obj ) ) {
          return false;
        }

        return type === "array" || length === 0 ||
          typeof length === "number" && length > 0 && ( length - 1 ) in obj;
      }
      var Sizzle =
      /*!
       * Sizzle CSS Selector Engine v2.3.4
       * https://sizzlejs.com/
       *
       * Copyright JS Foundation and other contributors
       * Released under the MIT license
       * https://js.foundation/
       *
       * Date: 2019-04-08
       */
      (function( window ) {

      var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,

        // Local document vars
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,

        // Instance-specific data
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        nonnativeSelectorCache = createCache(),
        sortOrder = function( a, b ) {
          if ( a === b ) {
            hasDuplicate = true;
          }
          return 0;
        },

        // Instance methods
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
        // https://jsperf.com/thor-indexof-vs-for/5
        indexOf = function( list, elem ) {
          var i = 0,
            len = list.length;
          for ( ; i < len; i++ ) {
            if ( list[i] === elem ) {
              return i;
            }
          }
          return -1;
        },

        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

        // Regular expressions

        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]",

        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
          // Operator (capture 2)
          "*([*^$|!~]?=)" + whitespace +
          // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
          "*\\]",

        pseudos = ":(" + identifier + ")(?:\\((" +
          // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
          // 1. quoted (capture 3; capture 4 or capture 5)
          "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
          // 2. simple (capture 6)
          "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
          // 3. anything else (capture 2)
          ".*" +
          ")\\)|)",

        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp( whitespace + "+", "g" ),
        rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

        rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
        rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
        rdescend = new RegExp( whitespace + "|>" ),

        rpseudo = new RegExp( pseudos ),
        ridentifier = new RegExp( "^" + identifier + "$" ),

        matchExpr = {
          "ID": new RegExp( "^#(" + identifier + ")" ),
          "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
          "TAG": new RegExp( "^(" + identifier + "|[*])" ),
          "ATTR": new RegExp( "^" + attributes ),
          "PSEUDO": new RegExp( "^" + pseudos ),
          "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
            "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
          "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
        },

        rhtml = /HTML$/i,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,

        rnative = /^[^{]+\{\s*\[native \w/,

        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

        rsibling = /[+~]/,

        // CSS escapes
        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
        funescape = function( _, escaped, escapedWhitespace ) {
          var high = "0x" + escaped - 0x10000;
          // NaN means non-codepoint
          // Support: Firefox<24
          // Workaround erroneous numeric interpretation of +"0x"
          return high !== high || escapedWhitespace ?
            escaped :
            high < 0 ?
              // BMP codepoint
              String.fromCharCode( high + 0x10000 ) :
              // Supplemental Plane codepoint (surrogate pair)
              String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
        },

        // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function( ch, asCodePoint ) {
          if ( asCodePoint ) {

            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
            if ( ch === "\0" ) {
              return "\uFFFD";
            }

            // Control characters and (dependent upon position) numbers get escaped as code points
            return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
          }

          // Other potentially-special ASCII characters get backslash-escaped
          return "\\" + ch;
        },

        // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
          setDocument();
        },

        inDisabledFieldset = addCombinator(
          function( elem ) {
            return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
          },
          { dir: "parentNode", next: "legend" }
        );

      // Optimize for push.apply( _, NodeList )
      try {
        push.apply(
          (arr = slice.call( preferredDoc.childNodes )),
          preferredDoc.childNodes
        );
        // Support: Android<4.0
        // Detect silently failing push.apply
        arr[ preferredDoc.childNodes.length ].nodeType;
      } catch ( e ) {
        push = { apply: arr.length ?

          // Leverage slice if possible
          function( target, els ) {
            push_native.apply( target, slice.call(els) );
          } :

          // Support: IE<9
          // Otherwise append directly
          function( target, els ) {
            var j = target.length,
              i = 0;
            // Can't trust NodeList.length
            while ( (target[j++] = els[i++]) ) {}
            target.length = j - 1;
          }
        };
      }

      function Sizzle( selector, context, results, seed ) {
        var m, i, elem, nid, match, groups, newSelector,
          newContext = context && context.ownerDocument,

          // nodeType defaults to 9, since context defaults to document
          nodeType = context ? context.nodeType : 9;

        results = results || [];

        // Return early from calls with invalid selector or context
        if ( typeof selector !== "string" || !selector ||
          nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

          return results;
        }

        // Try to shortcut find operations (as opposed to filters) in HTML documents
        if ( !seed ) {

          if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
            setDocument( context );
          }
          context = context || document;

          if ( documentIsHTML ) {

            // If the selector is sufficiently simple, try using a "get*By*" DOM method
            // (excepting DocumentFragment context, where the methods don't exist)
            if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

              // ID selector
              if ( (m = match[1]) ) {

                // Document context
                if ( nodeType === 9 ) {
                  if ( (elem = context.getElementById( m )) ) {

                    // Support: IE, Opera, Webkit
                    // TODO: identify versions
                    // getElementById can match elements by name instead of ID
                    if ( elem.id === m ) {
                      results.push( elem );
                      return results;
                    }
                  } else {
                    return results;
                  }

                // Element context
                } else {

                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if ( newContext && (elem = newContext.getElementById( m )) &&
                    contains( context, elem ) &&
                    elem.id === m ) {

                    results.push( elem );
                    return results;
                  }
                }

              // Type selector
              } else if ( match[2] ) {
                push.apply( results, context.getElementsByTagName( selector ) );
                return results;

              // Class selector
              } else if ( (m = match[3]) && support.getElementsByClassName &&
                context.getElementsByClassName ) {

                push.apply( results, context.getElementsByClassName( m ) );
                return results;
              }
            }

            // Take advantage of querySelectorAll
            if ( support.qsa &&
              !nonnativeSelectorCache[ selector + " " ] &&
              (!rbuggyQSA || !rbuggyQSA.test( selector )) &&

              // Support: IE 8 only
              // Exclude object elements
              (nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

              newSelector = selector;
              newContext = context;

              // qSA considers elements outside a scoping root when evaluating child or
              // descendant combinators, which is not what we want.
              // In such cases, we work around the behavior by prefixing every selector in the
              // list with an ID selector referencing the scope context.
              // Thanks to Andrew Dupont for this technique.
              if ( nodeType === 1 && rdescend.test( selector ) ) {

                // Capture the context ID, setting it first if necessary
                if ( (nid = context.getAttribute( "id" )) ) {
                  nid = nid.replace( rcssescape, fcssescape );
                } else {
                  context.setAttribute( "id", (nid = expando) );
                }

                // Prefix every selector in the list
                groups = tokenize( selector );
                i = groups.length;
                while ( i-- ) {
                  groups[i] = "#" + nid + " " + toSelector( groups[i] );
                }
                newSelector = groups.join( "," );

                // Expand context for sibling selectors
                newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
                  context;
              }

              try {
                push.apply( results,
                  newContext.querySelectorAll( newSelector )
                );
                return results;
              } catch ( qsaError ) {
                nonnativeSelectorCache( selector, true );
              } finally {
                if ( nid === expando ) {
                  context.removeAttribute( "id" );
                }
              }
            }
          }
        }

        // All others
        return select( selector.replace( rtrim, "$1" ), context, results, seed );
      }

      /**
       * Create key-value caches of limited size
       * @returns {function(string, object)} Returns the Object data after storing it on itself with
       *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
       *  deleting the oldest entry
       */
      function createCache() {
        var keys = [];

        function cache( key, value ) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if ( keys.push( key + " " ) > Expr.cacheLength ) {
            // Only keep the most recent entries
            delete cache[ keys.shift() ];
          }
          return (cache[ key + " " ] = value);
        }
        return cache;
      }

      /**
       * Mark a function for special use by Sizzle
       * @param {Function} fn The function to mark
       */
      function markFunction( fn ) {
        fn[ expando ] = true;
        return fn;
      }

      /**
       * Support testing using an element
       * @param {Function} fn Passed the created element and returns a boolean result
       */
      function assert( fn ) {
        var el = document.createElement("fieldset");

        try {
          return !!fn( el );
        } catch (e) {
          return false;
        } finally {
          // Remove from its parent by default
          if ( el.parentNode ) {
            el.parentNode.removeChild( el );
          }
          // release memory in IE
          el = null;
        }
      }

      /**
       * Adds the same handler for all of the specified attrs
       * @param {String} attrs Pipe-separated list of attributes
       * @param {Function} handler The method that will be applied
       */
      function addHandle( attrs, handler ) {
        var arr = attrs.split("|"),
          i = arr.length;

        while ( i-- ) {
          Expr.attrHandle[ arr[i] ] = handler;
        }
      }

      /**
       * Checks document order of two siblings
       * @param {Element} a
       * @param {Element} b
       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
       */
      function siblingCheck( a, b ) {
        var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
            a.sourceIndex - b.sourceIndex;

        // Use IE sourceIndex if available on both nodes
        if ( diff ) {
          return diff;
        }

        // Check if b follows a
        if ( cur ) {
          while ( (cur = cur.nextSibling) ) {
            if ( cur === b ) {
              return -1;
            }
          }
        }

        return a ? 1 : -1;
      }

      /**
       * Returns a function to use in pseudos for input types
       * @param {String} type
       */
      function createInputPseudo( type ) {
        return function( elem ) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for buttons
       * @param {String} type
       */
      function createButtonPseudo( type ) {
        return function( elem ) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for :enabled/:disabled
       * @param {Boolean} disabled true for :disabled; false for :enabled
       */
      function createDisabledPseudo( disabled ) {

        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
        return function( elem ) {

          // Only certain elements can match :enabled or :disabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
          if ( "form" in elem ) {

            // Check for inherited disabledness on relevant non-disabled elements:
            // * listed form-associated elements in a disabled fieldset
            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
            // * option elements in a disabled optgroup
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
            // All such elements have a "form" property.
            if ( elem.parentNode && elem.disabled === false ) {

              // Option elements defer to a parent optgroup if present
              if ( "label" in elem ) {
                if ( "label" in elem.parentNode ) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              }

              // Support: IE 6 - 11
              // Use the isDisabled shortcut property to check for disabled fieldset ancestors
              return elem.isDisabled === disabled ||

                // Where there is no isDisabled, check manually
                /* jshint -W018 */
                elem.isDisabled !== !disabled &&
                  inDisabledFieldset( elem ) === disabled;
            }

            return elem.disabled === disabled;

          // Try to winnow out elements that can't be disabled before trusting the disabled property.
          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
          // even exist on them, let alone have a boolean value.
          } else if ( "label" in elem ) {
            return elem.disabled === disabled;
          }

          // Remaining elements are neither :enabled nor :disabled
          return false;
        };
      }

      /**
       * Returns a function to use in pseudos for positionals
       * @param {Function} fn
       */
      function createPositionalPseudo( fn ) {
        return markFunction(function( argument ) {
          argument = +argument;
          return markFunction(function( seed, matches ) {
            var j,
              matchIndexes = fn( [], seed.length, argument ),
              i = matchIndexes.length;

            // Match elements found at the specified indexes
            while ( i-- ) {
              if ( seed[ (j = matchIndexes[i]) ] ) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }

      /**
       * Checks a node for validity as a Sizzle context
       * @param {Element|Object=} context
       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
       */
      function testContext( context ) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      }

      // Expose support vars for convenience
      support = Sizzle.support = {};

      /**
       * Detects XML nodes
       * @param {Element|Object} elem An element or a document
       * @returns {Boolean} True iff elem is a non-HTML XML node
       */
      isXML = Sizzle.isXML = function( elem ) {
        var namespace = elem.namespaceURI,
          docElem = (elem.ownerDocument || elem).documentElement;

        // Support: IE <=8
        // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
        // https://bugs.jquery.com/ticket/4833
        return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
      };

      /**
       * Sets document-related variables once based on the current document
       * @param {Element|Object} [doc] An element or document object to use to set the document
       * @returns {Object} Returns the current document
       */
      setDocument = Sizzle.setDocument = function( node ) {
        var hasCompare, subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc;

        // Return early if doc is invalid or already selected
        if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
          return document;
        }

        // Update global variables
        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML( document );

        // Support: IE 9-11, Edge
        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
        if ( preferredDoc !== document &&
          (subWindow = document.defaultView) && subWindow.top !== subWindow ) {

          // Support: IE 11, Edge
          if ( subWindow.addEventListener ) {
            subWindow.addEventListener( "unload", unloadHandler, false );

          // Support: IE 9 - 10 only
          } else if ( subWindow.attachEvent ) {
            subWindow.attachEvent( "onunload", unloadHandler );
          }
        }

        /* Attributes
        ---------------------------------------------------------------------- */

        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)
        support.attributes = assert(function( el ) {
          el.className = "i";
          return !el.getAttribute("className");
        });

        /* getElement(s)By*
        ---------------------------------------------------------------------- */

        // Check if getElementsByTagName("*") returns only elements
        support.getElementsByTagName = assert(function( el ) {
          el.appendChild( document.createComment("") );
          return !el.getElementsByTagName("*").length;
        });

        // Support: IE<9
        support.getElementsByClassName = rnative.test( document.getElementsByClassName );

        // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programmatically-set names,
        // so use a roundabout getElementsByName test
        support.getById = assert(function( el ) {
          docElem.appendChild( el ).id = expando;
          return !document.getElementsByName || !document.getElementsByName( expando ).length;
        });

        // ID filter and find
        if ( support.getById ) {
          Expr.filter["ID"] = function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
              return elem.getAttribute("id") === attrId;
            };
          };
          Expr.find["ID"] = function( id, context ) {
            if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
              var elem = context.getElementById( id );
              return elem ? [ elem ] : [];
            }
          };
        } else {
          Expr.filter["ID"] =  function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
              var node = typeof elem.getAttributeNode !== "undefined" &&
                elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          };

          // Support: IE 6 - 7 only
          // getElementById is not reliable as a find shortcut
          Expr.find["ID"] = function( id, context ) {
            if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
              var node, i, elems,
                elem = context.getElementById( id );

              if ( elem ) {

                // Verify the id attribute
                node = elem.getAttributeNode("id");
                if ( node && node.value === id ) {
                  return [ elem ];
                }

                // Fall back on getElementsByName
                elems = context.getElementsByName( id );
                i = 0;
                while ( (elem = elems[i++]) ) {
                  node = elem.getAttributeNode("id");
                  if ( node && node.value === id ) {
                    return [ elem ];
                  }
                }
              }

              return [];
            }
          };
        }

        // Tag
        Expr.find["TAG"] = support.getElementsByTagName ?
          function( tag, context ) {
            if ( typeof context.getElementsByTagName !== "undefined" ) {
              return context.getElementsByTagName( tag );

            // DocumentFragment nodes don't have gEBTN
            } else if ( support.qsa ) {
              return context.querySelectorAll( tag );
            }
          } :

          function( tag, context ) {
            var elem,
              tmp = [],
              i = 0,
              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
              results = context.getElementsByTagName( tag );

            // Filter out possible comments
            if ( tag === "*" ) {
              while ( (elem = results[i++]) ) {
                if ( elem.nodeType === 1 ) {
                  tmp.push( elem );
                }
              }

              return tmp;
            }
            return results;
          };

        // Class
        Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
          if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
            return context.getElementsByClassName( className );
          }
        };

        /* QSA/matchesSelector
        ---------------------------------------------------------------------- */

        // QSA and matchesSelector support

        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
        rbuggyMatches = [];

        // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See https://bugs.jquery.com/ticket/13378
        rbuggyQSA = [];

        if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function( el ) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // https://bugs.jquery.com/ticket/12359
            docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
              "<select id='" + expando + "-\r\\' msallowcapture=''>" +
              "<option selected=''></option></select>";

            // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
            if ( el.querySelectorAll("[msallowcapture^='']").length ) {
              rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
            }

            // Support: IE8
            // Boolean attributes and "value" are not treated correctly
            if ( !el.querySelectorAll("[selected]").length ) {
              rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
            }

            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
            if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
              rbuggyQSA.push("~=");
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests
            if ( !el.querySelectorAll(":checked").length ) {
              rbuggyQSA.push(":checked");
            }

            // Support: Safari 8+, iOS 8+
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibling-combinator selector` fails
            if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });

          assert(function( el ) {
            el.innerHTML = "<a href='' disabled='disabled'></a>" +
              "<select disabled='disabled'><option/></select>";

            // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment
            var input = document.createElement("input");
            input.setAttribute( "type", "hidden" );
            el.appendChild( input ).setAttribute( "name", "D" );

            // Support: IE8
            // Enforce case-sensitivity of name attribute
            if ( el.querySelectorAll("[name=d]").length ) {
              rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests
            if ( el.querySelectorAll(":enabled").length !== 2 ) {
              rbuggyQSA.push( ":enabled", ":disabled" );
            }

            // Support: IE9-11+
            // IE's :disabled selector does not pick up the children of disabled fieldsets
            docElem.appendChild( el ).disabled = true;
            if ( el.querySelectorAll(":disabled").length !== 2 ) {
              rbuggyQSA.push( ":enabled", ":disabled" );
            }

            // Opera 10-11 does not throw on post-comma invalid pseudos
            el.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }

        if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
          docElem.webkitMatchesSelector ||
          docElem.mozMatchesSelector ||
          docElem.oMatchesSelector ||
          docElem.msMatchesSelector) )) ) {

          assert(function( el ) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call( el, "*" );

            // This should fail with an exception
            // Gecko does not error, returns false instead
            matches.call( el, "[s!='']:x" );
            rbuggyMatches.push( "!=", pseudos );
          });
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
        rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

        /* Contains
        ---------------------------------------------------------------------- */
        hasCompare = rnative.test( docElem.compareDocumentPosition );

        // Element contains another
        // Purposefully self-exclusive
        // As in, an element does not contain itself
        contains = hasCompare || rnative.test( docElem.contains ) ?
          function( a, b ) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
              bup = b && b.parentNode;
            return a === bup || !!( bup && bup.nodeType === 1 && (
              adown.contains ?
                adown.contains( bup ) :
                a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
            ));
          } :
          function( a, b ) {
            if ( b ) {
              while ( (b = b.parentNode) ) {
                if ( b === a ) {
                  return true;
                }
              }
            }
            return false;
          };

        /* Sorting
        ---------------------------------------------------------------------- */

        // Document order sorting
        sortOrder = hasCompare ?
        function( a, b ) {

          // Flag for duplicate removal
          if ( a === b ) {
            hasDuplicate = true;
            return 0;
          }

          // Sort on method existence if only one input has compareDocumentPosition
          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          if ( compare ) {
            return compare;
          }

          // Calculate position if both inputs belong to the same document
          compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
            a.compareDocumentPosition( b ) :

            // Otherwise we know they are disconnected
            1;

          // Disconnected nodes
          if ( compare & 1 ||
            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

            // Choose the first element that is related to our preferred document
            if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
              return -1;
            }
            if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
              return 1;
            }

            // Maintain original order
            return sortInput ?
              ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
              0;
          }

          return compare & 4 ? -1 : 1;
        } :
        function( a, b ) {
          // Exit early if the nodes are identical
          if ( a === b ) {
            hasDuplicate = true;
            return 0;
          }

          var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [ a ],
            bp = [ b ];

          // Parentless nodes are either documents or disconnected
          if ( !aup || !bup ) {
            return a === document ? -1 :
              b === document ? 1 :
              aup ? -1 :
              bup ? 1 :
              sortInput ?
              ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
              0;

          // If the nodes are siblings, we can do a quick check
          } else if ( aup === bup ) {
            return siblingCheck( a, b );
          }

          // Otherwise we need full lists of their ancestors for comparison
          cur = a;
          while ( (cur = cur.parentNode) ) {
            ap.unshift( cur );
          }
          cur = b;
          while ( (cur = cur.parentNode) ) {
            bp.unshift( cur );
          }

          // Walk down the tree looking for a discrepancy
          while ( ap[i] === bp[i] ) {
            i++;
          }

          return i ?
            // Do a sibling check if the nodes have a common ancestor
            siblingCheck( ap[i], bp[i] ) :

            // Otherwise nodes in our document sort first
            ap[i] === preferredDoc ? -1 :
            bp[i] === preferredDoc ? 1 :
            0;
        };

        return document;
      };

      Sizzle.matches = function( expr, elements ) {
        return Sizzle( expr, null, null, elements );
      };

      Sizzle.matchesSelector = function( elem, expr ) {
        // Set document vars if needed
        if ( ( elem.ownerDocument || elem ) !== document ) {
          setDocument( elem );
        }

        if ( support.matchesSelector && documentIsHTML &&
          !nonnativeSelectorCache[ expr + " " ] &&
          ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
          ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

          try {
            var ret = matches.call( elem, expr );

            // IE 9's matchesSelector returns false on disconnected nodes
            if ( ret || support.disconnectedMatch ||
                // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11 ) {
              return ret;
            }
          } catch (e) {
            nonnativeSelectorCache( expr, true );
          }
        }

        return Sizzle( expr, document, null, [ elem ] ).length > 0;
      };

      Sizzle.contains = function( context, elem ) {
        // Set document vars if needed
        if ( ( context.ownerDocument || context ) !== document ) {
          setDocument( context );
        }
        return contains( context, elem );
      };

      Sizzle.attr = function( elem, name ) {
        // Set document vars if needed
        if ( ( elem.ownerDocument || elem ) !== document ) {
          setDocument( elem );
        }

        var fn = Expr.attrHandle[ name.toLowerCase() ],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
          val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
            fn( elem, name, !documentIsHTML ) :
            undefined;

        return val !== undefined ?
          val :
          support.attributes || !documentIsHTML ?
            elem.getAttribute( name ) :
            (val = elem.getAttributeNode(name)) && val.specified ?
              val.value :
              null;
      };

      Sizzle.escape = function( sel ) {
        return (sel + "").replace( rcssescape, fcssescape );
      };

      Sizzle.error = function( msg ) {
        throw new Error( "Syntax error, unrecognized expression: " + msg );
      };

      /**
       * Document sorting and removing duplicates
       * @param {ArrayLike} results
       */
      Sizzle.uniqueSort = function( results ) {
        var elem,
          duplicates = [],
          j = 0,
          i = 0;

        // Unless we *know* we can detect duplicates, assume their presence
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice( 0 );
        results.sort( sortOrder );

        if ( hasDuplicate ) {
          while ( (elem = results[i++]) ) {
            if ( elem === results[ i ] ) {
              j = duplicates.push( i );
            }
          }
          while ( j-- ) {
            results.splice( duplicates[ j ], 1 );
          }
        }

        // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225
        sortInput = null;

        return results;
      };

      /**
       * Utility function for retrieving the text value of an array of DOM nodes
       * @param {Array|Element} elem
       */
      getText = Sizzle.getText = function( elem ) {
        var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

        if ( !nodeType ) {
          // If no nodeType, this is expected to be an array
          while ( (node = elem[i++]) ) {
            // Do not traverse comment nodes
            ret += getText( node );
          }
        } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if ( typeof elem.textContent === "string" ) {
            return elem.textContent;
          } else {
            // Traverse its children
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
              ret += getText( elem );
            }
          }
        } else if ( nodeType === 3 || nodeType === 4 ) {
          return elem.nodeValue;
        }
        // Do not include comment or processing instruction nodes

        return ret;
      };

      Expr = Sizzle.selectors = {

        // Can be adjusted by the user
        cacheLength: 50,

        createPseudo: markFunction,

        match: matchExpr,

        attrHandle: {},

        find: {},

        relative: {
          ">": { dir: "parentNode", first: true },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: true },
          "~": { dir: "previousSibling" }
        },

        preFilter: {
          "ATTR": function( match ) {
            match[1] = match[1].replace( runescape, funescape );

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

            if ( match[2] === "~=" ) {
              match[3] = " " + match[3] + " ";
            }

            return match.slice( 0, 4 );
          },

          "CHILD": function( match ) {
            /* matches from matchExpr["CHILD"]
              1 type (only|nth|...)
              2 what (child|of-type)
              3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
              4 xn-component of xn+y argument ([+-]?\d*n|)
              5 sign of xn-component
              6 x of xn-component
              7 sign of y-component
              8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if ( match[1].slice( 0, 3 ) === "nth" ) {
              // nth-* requires argument
              if ( !match[3] ) {
                Sizzle.error( match[0] );
              }

              // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1
              match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
              match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

            // other types prohibit arguments
            } else if ( match[3] ) {
              Sizzle.error( match[0] );
            }

            return match;
          },

          "PSEUDO": function( match ) {
            var excess,
              unquoted = !match[6] && match[2];

            if ( matchExpr["CHILD"].test( match[0] ) ) {
              return null;
            }

            // Accept quoted arguments as-is
            if ( match[3] ) {
              match[2] = match[4] || match[5] || "";

            // Strip excess characters from unquoted arguments
            } else if ( unquoted && rpseudo.test( unquoted ) &&
              // Get excess from tokenize (recursively)
              (excess = tokenize( unquoted, true )) &&
              // advance to the next closing parenthesis
              (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

              // excess is a negative index
              match[0] = match[0].slice( 0, excess );
              match[2] = unquoted.slice( 0, excess );
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice( 0, 3 );
          }
        },

        filter: {

          "TAG": function( nodeNameSelector ) {
            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
            return nodeNameSelector === "*" ?
              function() { return true; } :
              function( elem ) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
              };
          },

          "CLASS": function( className ) {
            var pattern = classCache[ className + " " ];

            return pattern ||
              (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
              classCache( className, function( elem ) {
                return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
              });
          },

          "ATTR": function( name, operator, check ) {
            return function( elem ) {
              var result = Sizzle.attr( elem, name );

              if ( result == null ) {
                return operator === "!=";
              }
              if ( !operator ) {
                return true;
              }

              result += "";

              return operator === "=" ? result === check :
                operator === "!=" ? result !== check :
                operator === "^=" ? check && result.indexOf( check ) === 0 :
                operator === "*=" ? check && result.indexOf( check ) > -1 :
                operator === "$=" ? check && result.slice( -check.length ) === check :
                operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                false;
            };
          },

          "CHILD": function( type, what, argument, first, last ) {
            var simple = type.slice( 0, 3 ) !== "nth",
              forward = type.slice( -4 ) !== "last",
              ofType = what === "of-type";

            return first === 1 && last === 0 ?

              // Shortcut for :nth-*(n)
              function( elem ) {
                return !!elem.parentNode;
              } :

              function( elem, context, xml ) {
                var cache, uniqueCache, outerCache, node, nodeIndex, start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType && elem.nodeName.toLowerCase(),
                  useCache = !xml && !ofType,
                  diff = false;

                if ( parent ) {

                  // :(first|last|only)-(child|of-type)
                  if ( simple ) {
                    while ( dir ) {
                      node = elem;
                      while ( (node = node[ dir ]) ) {
                        if ( ofType ?
                          node.nodeName.toLowerCase() === name :
                          node.nodeType === 1 ) {

                          return false;
                        }
                      }
                      // Reverse direction for :only-* (if we haven't yet done so)
                      start = dir = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }

                  start = [ forward ? parent.firstChild : parent.lastChild ];

                  // non-xml :nth-child(...) stores cache data on `parent`
                  if ( forward && useCache ) {

                    // Seek `elem` from a previously-cached index

                    // ...in a gzip-friendly way
                    node = parent;
                    outerCache = node[ expando ] || (node[ expando ] = {});

                    // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)
                    uniqueCache = outerCache[ node.uniqueID ] ||
                      (outerCache[ node.uniqueID ] = {});

                    cache = uniqueCache[ type ] || [];
                    nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                    diff = nodeIndex && cache[ 2 ];
                    node = nodeIndex && parent.childNodes[ nodeIndex ];

                    while ( (node = ++nodeIndex && node && node[ dir ] ||

                      // Fallback to seeking `elem` from the start
                      (diff = nodeIndex = 0) || start.pop()) ) {

                      // When found, cache indexes on `parent` and break
                      if ( node.nodeType === 1 && ++diff && node === elem ) {
                        uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                        break;
                      }
                    }

                  } else {
                    // Use previously-cached element index if available
                    if ( useCache ) {
                      // ...in a gzip-friendly way
                      node = elem;
                      outerCache = node[ expando ] || (node[ expando ] = {});

                      // Support: IE <9 only
                      // Defend against cloned attroperties (jQuery gh-1709)
                      uniqueCache = outerCache[ node.uniqueID ] ||
                        (outerCache[ node.uniqueID ] = {});

                      cache = uniqueCache[ type ] || [];
                      nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                      diff = nodeIndex;
                    }

                    // xml :nth-child(...)
                    // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                    if ( diff === false ) {
                      // Use the same loop as above to seek `elem` from the start
                      while ( (node = ++nodeIndex && node && node[ dir ] ||
                        (diff = nodeIndex = 0) || start.pop()) ) {

                        if ( ( ofType ?
                          node.nodeName.toLowerCase() === name :
                          node.nodeType === 1 ) &&
                          ++diff ) {

                          // Cache the index of each encountered element
                          if ( useCache ) {
                            outerCache = node[ expando ] || (node[ expando ] = {});

                            // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)
                            uniqueCache = outerCache[ node.uniqueID ] ||
                              (outerCache[ node.uniqueID ] = {});

                            uniqueCache[ type ] = [ dirruns, diff ];
                          }

                          if ( node === elem ) {
                            break;
                          }
                        }
                      }
                    }
                  }

                  // Incorporate the offset, then check against cycle size
                  diff -= last;
                  return diff === first || ( diff % first === 0 && diff / first >= 0 );
                }
              };
          },

          "PSEUDO": function( pseudo, argument ) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
              fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                Sizzle.error( "unsupported pseudo: " + pseudo );

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if ( fn[ expando ] ) {
              return fn( argument );
            }

            // But maintain support for old signatures
            if ( fn.length > 1 ) {
              args = [ pseudo, pseudo, "", argument ];
              return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                markFunction(function( seed, matches ) {
                  var idx,
                    matched = fn( seed, argument ),
                    i = matched.length;
                  while ( i-- ) {
                    idx = indexOf( seed, matched[i] );
                    seed[ idx ] = !( matches[ idx ] = matched[i] );
                  }
                }) :
                function( elem ) {
                  return fn( elem, 0, args );
                };
            }

            return fn;
          }
        },

        pseudos: {
          // Potentially complex pseudos
          "not": markFunction(function( selector ) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
              results = [],
              matcher = compile( selector.replace( rtrim, "$1" ) );

            return matcher[ expando ] ?
              markFunction(function( seed, matches, context, xml ) {
                var elem,
                  unmatched = matcher( seed, null, xml, [] ),
                  i = seed.length;

                // Match elements unmatched by `matcher`
                while ( i-- ) {
                  if ( (elem = unmatched[i]) ) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              }) :
              function( elem, context, xml ) {
                input[0] = elem;
                matcher( input, null, xml, results );
                // Don't keep the element (issue #299)
                input[0] = null;
                return !results.pop();
              };
          }),

          "has": markFunction(function( selector ) {
            return function( elem ) {
              return Sizzle( selector, elem ).length > 0;
            };
          }),

          "contains": markFunction(function( text ) {
            text = text.replace( runescape, funescape );
            return function( elem ) {
              return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
            };
          }),

          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // http://www.w3.org/TR/selectors/#lang-pseudo
          "lang": markFunction( function( lang ) {
            // lang value must be a valid identifier
            if ( !ridentifier.test(lang || "") ) {
              Sizzle.error( "unsupported lang: " + lang );
            }
            lang = lang.replace( runescape, funescape ).toLowerCase();
            return function( elem ) {
              var elemLang;
              do {
                if ( (elemLang = documentIsHTML ?
                  elem.lang :
                  elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                }
              } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
              return false;
            };
          }),

          // Miscellaneous
          "target": function( elem ) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice( 1 ) === elem.id;
          },

          "root": function( elem ) {
            return elem === docElem;
          },

          "focus": function( elem ) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },

          // Boolean properties
          "enabled": createDisabledPseudo( false ),
          "disabled": createDisabledPseudo( true ),

          "checked": function( elem ) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
          },

          "selected": function( elem ) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if ( elem.parentNode ) {
              elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
          },

          // Contents
          "empty": function( elem ) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
              if ( elem.nodeType < 6 ) {
                return false;
              }
            }
            return true;
          },

          "parent": function( elem ) {
            return !Expr.pseudos["empty"]( elem );
          },

          // Element/input types
          "header": function( elem ) {
            return rheader.test( elem.nodeName );
          },

          "input": function( elem ) {
            return rinputs.test( elem.nodeName );
          },

          "button": function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
          },

          "text": function( elem ) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" &&
              elem.type === "text" &&

              // Support: IE<8
              // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
              ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
          },

          // Position-in-collection
          "first": createPositionalPseudo(function() {
            return [ 0 ];
          }),

          "last": createPositionalPseudo(function( matchIndexes, length ) {
            return [ length - 1 ];
          }),

          "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
            return [ argument < 0 ? argument + length : argument ];
          }),

          "even": createPositionalPseudo(function( matchIndexes, length ) {
            var i = 0;
            for ( ; i < length; i += 2 ) {
              matchIndexes.push( i );
            }
            return matchIndexes;
          }),

          "odd": createPositionalPseudo(function( matchIndexes, length ) {
            var i = 1;
            for ( ; i < length; i += 2 ) {
              matchIndexes.push( i );
            }
            return matchIndexes;
          }),

          "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument < 0 ?
              argument + length :
              argument > length ?
                length :
                argument;
            for ( ; --i >= 0; ) {
              matchIndexes.push( i );
            }
            return matchIndexes;
          }),

          "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument < 0 ? argument + length : argument;
            for ( ; ++i < length; ) {
              matchIndexes.push( i );
            }
            return matchIndexes;
          })
        }
      };

      Expr.pseudos["nth"] = Expr.pseudos["eq"];

      // Add button/input type pseudos
      for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
        Expr.pseudos[ i ] = createInputPseudo( i );
      }
      for ( i in { submit: true, reset: true } ) {
        Expr.pseudos[ i ] = createButtonPseudo( i );
      }

      // Easy API for creating new setFilters
      function setFilters() {}
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();

      tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
        var matched, match, tokens, type,
          soFar, groups, preFilters,
          cached = tokenCache[ selector + " " ];

        if ( cached ) {
          return parseOnly ? 0 : cached.slice( 0 );
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while ( soFar ) {

          // Comma and first run
          if ( !matched || (match = rcomma.exec( soFar )) ) {
            if ( match ) {
              // Don't consume trailing commas as valid
              soFar = soFar.slice( match[0].length ) || soFar;
            }
            groups.push( (tokens = []) );
          }

          matched = false;

          // Combinators
          if ( (match = rcombinators.exec( soFar )) ) {
            matched = match.shift();
            tokens.push({
              value: matched,
              // Cast descendant combinators to space
              type: match[0].replace( rtrim, " " )
            });
            soFar = soFar.slice( matched.length );
          }

          // Filters
          for ( type in Expr.filter ) {
            if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
              (match = preFilters[ type ]( match ))) ) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice( matched.length );
            }
          }

          if ( !matched ) {
            break;
          }
        }

        // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens
        return parseOnly ?
          soFar.length :
          soFar ?
            Sizzle.error( selector ) :
            // Cache the tokens
            tokenCache( selector, groups ).slice( 0 );
      };

      function toSelector( tokens ) {
        var i = 0,
          len = tokens.length,
          selector = "";
        for ( ; i < len; i++ ) {
          selector += tokens[i].value;
        }
        return selector;
      }

      function addCombinator( matcher, combinator, base ) {
        var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;

        return combinator.first ?
          // Check against closest ancestor/preceding element
          function( elem, context, xml ) {
            while ( (elem = elem[ dir ]) ) {
              if ( elem.nodeType === 1 || checkNonElements ) {
                return matcher( elem, context, xml );
              }
            }
            return false;
          } :

          // Check against all ancestor/preceding elements
          function( elem, context, xml ) {
            var oldCache, uniqueCache, outerCache,
              newCache = [ dirruns, doneName ];

            // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
            if ( xml ) {
              while ( (elem = elem[ dir ]) ) {
                if ( elem.nodeType === 1 || checkNonElements ) {
                  if ( matcher( elem, context, xml ) ) {
                    return true;
                  }
                }
              }
            } else {
              while ( (elem = elem[ dir ]) ) {
                if ( elem.nodeType === 1 || checkNonElements ) {
                  outerCache = elem[ expando ] || (elem[ expando ] = {});

                  // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)
                  uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

                  if ( skip && skip === elem.nodeName.toLowerCase() ) {
                    elem = elem[ dir ] || elem;
                  } else if ( (oldCache = uniqueCache[ key ]) &&
                    oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                    // Assign to newCache so results back-propagate to previous elements
                    return (newCache[ 2 ] = oldCache[ 2 ]);
                  } else {
                    // Reuse newcache so results back-propagate to previous elements
                    uniqueCache[ key ] = newCache;

                    // A match means we're done; a fail means we have to keep checking
                    if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                      return true;
                    }
                  }
                }
              }
            }
            return false;
          };
      }

      function elementMatcher( matchers ) {
        return matchers.length > 1 ?
          function( elem, context, xml ) {
            var i = matchers.length;
            while ( i-- ) {
              if ( !matchers[i]( elem, context, xml ) ) {
                return false;
              }
            }
            return true;
          } :
          matchers[0];
      }

      function multipleContexts( selector, contexts, results ) {
        var i = 0,
          len = contexts.length;
        for ( ; i < len; i++ ) {
          Sizzle( selector, contexts[i], results );
        }
        return results;
      }

      function condense( unmatched, map, filter, context, xml ) {
        var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

        for ( ; i < len; i++ ) {
          if ( (elem = unmatched[i]) ) {
            if ( !filter || filter( elem, context, xml ) ) {
              newUnmatched.push( elem );
              if ( mapped ) {
                map.push( i );
              }
            }
          }
        }

        return newUnmatched;
      }

      function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
        if ( postFilter && !postFilter[ expando ] ) {
          postFilter = setMatcher( postFilter );
        }
        if ( postFinder && !postFinder[ expando ] ) {
          postFinder = setMatcher( postFinder, postSelector );
        }
        return markFunction(function( seed, results, context, xml ) {
          var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,

            // Get initial elements from seed or context
            elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && ( seed || !selector ) ?
              condense( elems, preMap, preFilter, context, xml ) :
              elems,

            matcherOut = matcher ?
              // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
              postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                // ...intermediate processing is necessary
                [] :

                // ...otherwise use results directly
                results :
              matcherIn;

          // Find primary matches
          if ( matcher ) {
            matcher( matcherIn, matcherOut, context, xml );
          }

          // Apply postFilter
          if ( postFilter ) {
            temp = condense( matcherOut, postMap );
            postFilter( temp, [], context, xml );

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while ( i-- ) {
              if ( (elem = temp[i]) ) {
                matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
              }
            }
          }

          if ( seed ) {
            if ( postFinder || preFilter ) {
              if ( postFinder ) {
                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;
                while ( i-- ) {
                  if ( (elem = matcherOut[i]) ) {
                    // Restore matcherIn since elem is not yet a final match
                    temp.push( (matcherIn[i] = elem) );
                  }
                }
                postFinder( null, (matcherOut = []), temp, xml );
              }

              // Move matched elements from seed to results to keep them synchronized
              i = matcherOut.length;
              while ( i-- ) {
                if ( (elem = matcherOut[i]) &&
                  (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

                  seed[temp] = !(results[temp] = elem);
                }
              }
            }

          // Add elements to results, through postFinder if defined
          } else {
            matcherOut = condense(
              matcherOut === results ?
                matcherOut.splice( preexisting, matcherOut.length ) :
                matcherOut
            );
            if ( postFinder ) {
              postFinder( null, results, matcherOut, xml );
            } else {
              push.apply( results, matcherOut );
            }
          }
        });
      }

      function matcherFromTokens( tokens ) {
        var checkContext, matcher, j,
          len = tokens.length,
          leadingRelative = Expr.relative[ tokens[0].type ],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,

          // The foundational matcher ensures that elements are reachable from top-level context(s)
          matchContext = addCombinator( function( elem ) {
            return elem === checkContext;
          }, implicitRelative, true ),
          matchAnyContext = addCombinator( function( elem ) {
            return indexOf( checkContext, elem ) > -1;
          }, implicitRelative, true ),
          matchers = [ function( elem, context, xml ) {
            var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
              (checkContext = context).nodeType ?
                matchContext( elem, context, xml ) :
                matchAnyContext( elem, context, xml ) );
            // Avoid hanging onto element (issue #299)
            checkContext = null;
            return ret;
          } ];

        for ( ; i < len; i++ ) {
          if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
          } else {
            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

            // Return special upon seeing a positional matcher
            if ( matcher[ expando ] ) {
              // Find the next relative operator (if any) for proper handling
              j = ++i;
              for ( ; j < len; j++ ) {
                if ( Expr.relative[ tokens[j].type ] ) {
                  break;
                }
              }
              return setMatcher(
                i > 1 && elementMatcher( matchers ),
                i > 1 && toSelector(
                  // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                  tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                ).replace( rtrim, "$1" ),
                matcher,
                i < j && matcherFromTokens( tokens.slice( i, j ) ),
                j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                j < len && toSelector( tokens )
              );
            }
            matchers.push( matcher );
          }
        }

        return elementMatcher( matchers );
      }

      function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
        var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function( seed, context, xml, results, outermost ) {
            var elem, j, matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,
              // We must always have either seed elements or outermost context
              elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
              // Use integer dirruns iff this is the outermost matcher
              dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
              len = elems.length;

            if ( outermost ) {
              outermostContext = context === document || context || outermost;
            }

            // Add elements passing elementMatchers directly to results
            // Support: IE<9, Safari
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
            for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
              if ( byElement && elem ) {
                j = 0;
                if ( !context && elem.ownerDocument !== document ) {
                  setDocument( elem );
                  xml = !documentIsHTML;
                }
                while ( (matcher = elementMatchers[j++]) ) {
                  if ( matcher( elem, context || document, xml) ) {
                    results.push( elem );
                    break;
                  }
                }
                if ( outermost ) {
                  dirruns = dirrunsUnique;
                }
              }

              // Track unmatched elements for set filters
              if ( bySet ) {
                // They will have gone through all possible matchers
                if ( (elem = !matcher && elem) ) {
                  matchedCount--;
                }

                // Lengthen the array for every element, matched or not
                if ( seed ) {
                  unmatched.push( elem );
                }
              }
            }

            // `i` is now the count of elements visited above, and adding it to `matchedCount`
            // makes the latter nonnegative.
            matchedCount += i;

            // Apply set filters to unmatched elements
            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
            // no element matchers and no seed.
            // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
            // case, which will result in a "00" `matchedCount` that differs from `i` but is also
            // numerically zero.
            if ( bySet && i !== matchedCount ) {
              j = 0;
              while ( (matcher = setMatchers[j++]) ) {
                matcher( unmatched, setMatched, context, xml );
              }

              if ( seed ) {
                // Reintegrate element matches to eliminate the need for sorting
                if ( matchedCount > 0 ) {
                  while ( i-- ) {
                    if ( !(unmatched[i] || setMatched[i]) ) {
                      setMatched[i] = pop.call( results );
                    }
                  }
                }

                // Discard index placeholder values to get only actual matches
                setMatched = condense( setMatched );
              }

              // Add matches to results
              push.apply( results, setMatched );

              // Seedless set matches succeeding multiple successful matchers stipulate sorting
              if ( outermost && !seed && setMatched.length > 0 &&
                ( matchedCount + setMatchers.length ) > 1 ) {

                Sizzle.uniqueSort( results );
              }
            }

            // Override manipulation of globals by nested matchers
            if ( outermost ) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }

            return unmatched;
          };

        return bySet ?
          markFunction( superMatcher ) :
          superMatcher;
      }

      compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
        var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[ selector + " " ];

        if ( !cached ) {
          // Generate a function of recursive functions that can be used to check each element
          if ( !match ) {
            match = tokenize( selector );
          }
          i = match.length;
          while ( i-- ) {
            cached = matcherFromTokens( match[i] );
            if ( cached[ expando ] ) {
              setMatchers.push( cached );
            } else {
              elementMatchers.push( cached );
            }
          }

          // Cache the compiled function
          cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

          // Save selector and tokenization
          cached.selector = selector;
        }
        return cached;
      };

      /**
       * A low-level selection function that works with Sizzle's compiled
       *  selector functions
       * @param {String|Function} selector A selector or a pre-compiled
       *  selector function built with Sizzle.compile
       * @param {Element} context
       * @param {Array} [results]
       * @param {Array} [seed] A set of elements to match against
       */
      select = Sizzle.select = function( selector, context, results, seed ) {
        var i, tokens, token, type, find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize( (selector = compiled.selector || selector) );

        results = results || [];

        // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)
        if ( match.length === 1 ) {

          // Reduce context if the leading compound selector is an ID
          tokens = match[0] = match[0].slice( 0 );
          if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
              context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

            context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
            if ( !context ) {
              return results;

            // Precompiled matchers will still verify ancestry, so step up a level
            } else if ( compiled ) {
              context = context.parentNode;
            }

            selector = selector.slice( tokens.shift().value.length );
          }

          // Fetch a seed set for right-to-left matching
          i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
          while ( i-- ) {
            token = tokens[i];

            // Abort if we hit a combinator
            if ( Expr.relative[ (type = token.type) ] ) {
              break;
            }
            if ( (find = Expr.find[ type ]) ) {
              // Search, expanding context for leading sibling combinators
              if ( (seed = find(
                token.matches[0].replace( runescape, funescape ),
                rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
              )) ) {

                // If seed is empty or no tokens remain, we can return early
                tokens.splice( i, 1 );
                selector = seed.length && toSelector( tokens );
                if ( !selector ) {
                  push.apply( results, seed );
                  return results;
                }

                break;
              }
            }
          }
        }

        // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above
        ( compiled || compile( selector, match ) )(
          seed,
          context,
          !documentIsHTML,
          results,
          !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
        );
        return results;
      };

      // One-time assignments

      // Sort stability
      support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

      // Support: Chrome 14-35+
      // Always assume duplicates if they aren't passed to the comparison function
      support.detectDuplicates = !!hasDuplicate;

      // Initialize against the default document
      setDocument();

      // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
      // Detached nodes confoundingly follow *each other*
      support.sortDetached = assert(function( el ) {
        // Should return 1, but returns 4 (following)
        return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
      });

      // Support: IE<8
      // Prevent attribute/property "interpolation"
      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
      if ( !assert(function( el ) {
        el.innerHTML = "<a href='#'></a>";
        return el.firstChild.getAttribute("href") === "#" ;
      }) ) {
        addHandle( "type|href|height|width", function( elem, name, isXML ) {
          if ( !isXML ) {
            return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
          }
        });
      }

      // Support: IE<9
      // Use defaultValue in place of getAttribute("value")
      if ( !support.attributes || !assert(function( el ) {
        el.innerHTML = "<input/>";
        el.firstChild.setAttribute( "value", "" );
        return el.firstChild.getAttribute( "value" ) === "";
      }) ) {
        addHandle( "value", function( elem, name, isXML ) {
          if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
            return elem.defaultValue;
          }
        });
      }

      // Support: IE<9
      // Use getAttributeNode to fetch booleans when getAttribute lies
      if ( !assert(function( el ) {
        return el.getAttribute("disabled") == null;
      }) ) {
        addHandle( booleans, function( elem, name, isXML ) {
          var val;
          if ( !isXML ) {
            return elem[ name ] === true ? name.toLowerCase() :
                (val = elem.getAttributeNode( name )) && val.specified ?
                val.value :
              null;
          }
        });
      }

      return Sizzle;

      })( window );



      jQuery.find = Sizzle;
      jQuery.expr = Sizzle.selectors;

      // Deprecated
      jQuery.expr[ ":" ] = jQuery.expr.pseudos;
      jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
      jQuery.text = Sizzle.getText;
      jQuery.isXMLDoc = Sizzle.isXML;
      jQuery.contains = Sizzle.contains;
      jQuery.escapeSelector = Sizzle.escape;




      var dir = function( elem, dir, until ) {
        var matched = [],
          truncate = until !== undefined;

        while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
          if ( elem.nodeType === 1 ) {
            if ( truncate && jQuery( elem ).is( until ) ) {
              break;
            }
            matched.push( elem );
          }
        }
        return matched;
      };


      var siblings = function( n, elem ) {
        var matched = [];

        for ( ; n; n = n.nextSibling ) {
          if ( n.nodeType === 1 && n !== elem ) {
            matched.push( n );
          }
        }

        return matched;
      };


      var rneedsContext = jQuery.expr.match.needsContext;



      function nodeName( elem, name ) {

        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

      };
      var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



      // Implement the identical functionality for filter and not
      function winnow( elements, qualifier, not ) {
        if ( isFunction( qualifier ) ) {
          return jQuery.grep( elements, function( elem, i ) {
            return !!qualifier.call( elem, i, elem ) !== not;
          } );
        }

        // Single element
        if ( qualifier.nodeType ) {
          return jQuery.grep( elements, function( elem ) {
            return ( elem === qualifier ) !== not;
          } );
        }

        // Arraylike of elements (jQuery, arguments, Array)
        if ( typeof qualifier !== "string" ) {
          return jQuery.grep( elements, function( elem ) {
            return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
          } );
        }

        // Filtered directly for both simple and complex selectors
        return jQuery.filter( qualifier, elements, not );
      }

      jQuery.filter = function( expr, elems, not ) {
        var elem = elems[ 0 ];

        if ( not ) {
          expr = ":not(" + expr + ")";
        }

        if ( elems.length === 1 && elem.nodeType === 1 ) {
          return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
        }

        return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
          return elem.nodeType === 1;
        } ) );
      };

      jQuery.fn.extend( {
        find: function( selector ) {
          var i, ret,
            len = this.length,
            self = this;

          if ( typeof selector !== "string" ) {
            return this.pushStack( jQuery( selector ).filter( function() {
              for ( i = 0; i < len; i++ ) {
                if ( jQuery.contains( self[ i ], this ) ) {
                  return true;
                }
              }
            } ) );
          }

          ret = this.pushStack( [] );

          for ( i = 0; i < len; i++ ) {
            jQuery.find( selector, self[ i ], ret );
          }

          return len > 1 ? jQuery.uniqueSort( ret ) : ret;
        },
        filter: function( selector ) {
          return this.pushStack( winnow( this, selector || [], false ) );
        },
        not: function( selector ) {
          return this.pushStack( winnow( this, selector || [], true ) );
        },
        is: function( selector ) {
          return !!winnow(
            this,

            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test( selector ) ?
              jQuery( selector ) :
              selector || [],
            false
          ).length;
        }
      } );


      // Initialize a jQuery object


      // A central reference to the root jQuery(document)
      var rootjQuery,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        // Shortcut simple #id case for speed
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

        init = jQuery.fn.init = function( selector, context, root ) {
          var match, elem;

          // HANDLE: $(""), $(null), $(undefined), $(false)
          if ( !selector ) {
            return this;
          }

          // Method init() accepts an alternate rootjQuery
          // so migrate can support jQuery.sub (gh-2101)
          root = root || rootjQuery;

          // Handle HTML strings
          if ( typeof selector === "string" ) {
            if ( selector[ 0 ] === "<" &&
              selector[ selector.length - 1 ] === ">" &&
              selector.length >= 3 ) {

              // Assume that strings that start and end with <> are HTML and skip the regex check
              match = [ null, selector, null ];

            } else {
              match = rquickExpr.exec( selector );
            }

            // Match html or make sure no context is specified for #id
            if ( match && ( match[ 1 ] || !context ) ) {

              // HANDLE: $(html) -> $(array)
              if ( match[ 1 ] ) {
                context = context instanceof jQuery ? context[ 0 ] : context;

                // Option to run scripts is true for back-compat
                // Intentionally let the error be thrown if parseHTML is not present
                jQuery.merge( this, jQuery.parseHTML(
                  match[ 1 ],
                  context && context.nodeType ? context.ownerDocument || context : document,
                  true
                ) );

                // HANDLE: $(html, props)
                if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
                  for ( match in context ) {

                    // Properties of context are called as methods if possible
                    if ( isFunction( this[ match ] ) ) {
                      this[ match ]( context[ match ] );

                    // ...and otherwise set as attributes
                    } else {
                      this.attr( match, context[ match ] );
                    }
                  }
                }

                return this;

              // HANDLE: $(#id)
              } else {
                elem = document.getElementById( match[ 2 ] );

                if ( elem ) {

                  // Inject the element directly into the jQuery object
                  this[ 0 ] = elem;
                  this.length = 1;
                }
                return this;
              }

            // HANDLE: $(expr, $(...))
            } else if ( !context || context.jquery ) {
              return ( context || root ).find( selector );

            // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
            } else {
              return this.constructor( context ).find( selector );
            }

          // HANDLE: $(DOMElement)
          } else if ( selector.nodeType ) {
            this[ 0 ] = selector;
            this.length = 1;
            return this;

          // HANDLE: $(function)
          // Shortcut for document ready
          } else if ( isFunction( selector ) ) {
            return root.ready !== undefined ?
              root.ready( selector ) :

              // Execute immediately if ready is not present
              selector( jQuery );
          }

          return jQuery.makeArray( selector, this );
        };

      // Give the init function the jQuery prototype for later instantiation
      init.prototype = jQuery.fn;

      // Initialize central reference
      rootjQuery = jQuery( document );


      var rparentsprev = /^(?:parents|prev(?:Until|All))/,

        // Methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };

      jQuery.fn.extend( {
        has: function( target ) {
          var targets = jQuery( target, this ),
            l = targets.length;

          return this.filter( function() {
            var i = 0;
            for ( ; i < l; i++ ) {
              if ( jQuery.contains( this, targets[ i ] ) ) {
                return true;
              }
            }
          } );
        },

        closest: function( selectors, context ) {
          var cur,
            i = 0,
            l = this.length,
            matched = [],
            targets = typeof selectors !== "string" && jQuery( selectors );

          // Positional selectors never match, since there's no _selection_ context
          if ( !rneedsContext.test( selectors ) ) {
            for ( ; i < l; i++ ) {
              for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

                // Always skip document fragments
                if ( cur.nodeType < 11 && ( targets ?
                  targets.index( cur ) > -1 :

                  // Don't pass non-elements to Sizzle
                  cur.nodeType === 1 &&
                    jQuery.find.matchesSelector( cur, selectors ) ) ) {

                  matched.push( cur );
                  break;
                }
              }
            }
          }

          return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
        },

        // Determine the position of an element within the set
        index: function( elem ) {

          // No argument, return index in parent
          if ( !elem ) {
            return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
          }

          // Index in selector
          if ( typeof elem === "string" ) {
            return indexOf.call( jQuery( elem ), this[ 0 ] );
          }

          // Locate the position of the desired element
          return indexOf.call( this,

            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[ 0 ] : elem
          );
        },

        add: function( selector, context ) {
          return this.pushStack(
            jQuery.uniqueSort(
              jQuery.merge( this.get(), jQuery( selector, context ) )
            )
          );
        },

        addBack: function( selector ) {
          return this.add( selector == null ?
            this.prevObject : this.prevObject.filter( selector )
          );
        }
      } );

      function sibling( cur, dir ) {
        while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
        return cur;
      }

      jQuery.each( {
        parent: function( elem ) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function( elem ) {
          return dir( elem, "parentNode" );
        },
        parentsUntil: function( elem, i, until ) {
          return dir( elem, "parentNode", until );
        },
        next: function( elem ) {
          return sibling( elem, "nextSibling" );
        },
        prev: function( elem ) {
          return sibling( elem, "previousSibling" );
        },
        nextAll: function( elem ) {
          return dir( elem, "nextSibling" );
        },
        prevAll: function( elem ) {
          return dir( elem, "previousSibling" );
        },
        nextUntil: function( elem, i, until ) {
          return dir( elem, "nextSibling", until );
        },
        prevUntil: function( elem, i, until ) {
          return dir( elem, "previousSibling", until );
        },
        siblings: function( elem ) {
          return siblings( ( elem.parentNode || {} ).firstChild, elem );
        },
        children: function( elem ) {
          return siblings( elem.firstChild );
        },
        contents: function( elem ) {
          if ( typeof elem.contentDocument !== "undefined" ) {
            return elem.contentDocument;
          }

          // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
          // Treat the template element as a regular one in browsers that
          // don't support it.
          if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
          }

          return jQuery.merge( [], elem.childNodes );
        }
      }, function( name, fn ) {
        jQuery.fn[ name ] = function( until, selector ) {
          var matched = jQuery.map( this, fn, until );

          if ( name.slice( -5 ) !== "Until" ) {
            selector = until;
          }

          if ( selector && typeof selector === "string" ) {
            matched = jQuery.filter( selector, matched );
          }

          if ( this.length > 1 ) {

            // Remove duplicates
            if ( !guaranteedUnique[ name ] ) {
              jQuery.uniqueSort( matched );
            }

            // Reverse order for parents* and prev-derivatives
            if ( rparentsprev.test( name ) ) {
              matched.reverse();
            }
          }

          return this.pushStack( matched );
        };
      } );
      var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



      // Convert String-formatted options into Object-formatted ones
      function createOptions( options ) {
        var object = {};
        jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
          object[ flag ] = true;
        } );
        return object;
      }

      /*
       * Create a callback list using the following parameters:
       *
       *  options: an optional list of space-separated options that will change how
       *      the callback list behaves or a more traditional option object
       *
       * By default a callback list will act like an event callback list and can be
       * "fired" multiple times.
       *
       * Possible options:
       *
       *  once:     will ensure the callback list can only be fired once (like a Deferred)
       *
       *  memory:     will keep track of previous values and will call any callback added
       *          after the list has been fired right away with the latest "memorized"
       *          values (like a Deferred)
       *
       *  unique:     will ensure a callback can only be added once (no duplicate in the list)
       *
       *  stopOnFalse:  interrupt callings when a callback returns false
       *
       */
      jQuery.Callbacks = function( options ) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
          createOptions( options ) :
          jQuery.extend( {}, options );

        var // Flag to know if list is currently firing
          firing,

          // Last fire value for non-forgettable lists
          memory,

          // Flag to know if list was already fired
          fired,

          // Flag to prevent firing
          locked,

          // Actual callback list
          list = [],

          // Queue of execution data for repeatable lists
          queue = [],

          // Index of currently firing callback (modified by add/remove as needed)
          firingIndex = -1,

          // Fire callbacks
          fire = function() {

            // Enforce single-firing
            locked = locked || options.once;

            // Execute callbacks for all pending executions,
            // respecting firingIndex overrides and runtime changes
            fired = firing = true;
            for ( ; queue.length; firingIndex = -1 ) {
              memory = queue.shift();
              while ( ++firingIndex < list.length ) {

                // Run callback and check for early termination
                if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
                  options.stopOnFalse ) {

                  // Jump to end and forget the data so .add doesn't re-fire
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }

            // Forget the data if we're done with it
            if ( !options.memory ) {
              memory = false;
            }

            firing = false;

            // Clean up if we're done firing for good
            if ( locked ) {

              // Keep an empty list if we have data for future add calls
              if ( memory ) {
                list = [];

              // Otherwise, this object is spent
              } else {
                list = "";
              }
            }
          },

          // Actual Callbacks object
          self = {

            // Add a callback or a collection of callbacks to the list
            add: function() {
              if ( list ) {

                // If we have memory from a past run, we should fire after adding
                if ( memory && !firing ) {
                  firingIndex = list.length - 1;
                  queue.push( memory );
                }

                ( function add( args ) {
                  jQuery.each( args, function( _, arg ) {
                    if ( isFunction( arg ) ) {
                      if ( !options.unique || !self.has( arg ) ) {
                        list.push( arg );
                      }
                    } else if ( arg && arg.length && toType( arg ) !== "string" ) {

                      // Inspect recursively
                      add( arg );
                    }
                  } );
                } )( arguments );

                if ( memory && !firing ) {
                  fire();
                }
              }
              return this;
            },

            // Remove a callback from the list
            remove: function() {
              jQuery.each( arguments, function( _, arg ) {
                var index;
                while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                  list.splice( index, 1 );

                  // Handle firing indexes
                  if ( index <= firingIndex ) {
                    firingIndex--;
                  }
                }
              } );
              return this;
            },

            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function( fn ) {
              return fn ?
                jQuery.inArray( fn, list ) > -1 :
                list.length > 0;
            },

            // Remove all callbacks from the list
            empty: function() {
              if ( list ) {
                list = [];
              }
              return this;
            },

            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },

            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
              locked = queue = [];
              if ( !memory && !firing ) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },

            // Call all callbacks with the given context and arguments
            fireWith: function( context, args ) {
              if ( !locked ) {
                args = args || [];
                args = [ context, args.slice ? args.slice() : args ];
                queue.push( args );
                if ( !firing ) {
                  fire();
                }
              }
              return this;
            },

            // Call all the callbacks with the given arguments
            fire: function() {
              self.fireWith( this, arguments );
              return this;
            },

            // To know if the callbacks have already been called at least once
            fired: function() {
              return !!fired;
            }
          };

        return self;
      };


      function Identity( v ) {
        return v;
      }
      function Thrower( ex ) {
        throw ex;
      }

      function adoptValue( value, resolve, reject, noValue ) {
        var method;

        try {

          // Check for promise aspect first to privilege synchronous behavior
          if ( value && isFunction( ( method = value.promise ) ) ) {
            method.call( value ).done( resolve ).fail( reject );

          // Other thenables
          } else if ( value && isFunction( ( method = value.then ) ) ) {
            method.call( value, resolve, reject );

          // Other non-thenables
          } else {

            // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
            // * false: [ value ].slice( 0 ) => resolve( value )
            // * true: [ value ].slice( 1 ) => resolve()
            resolve.apply( undefined, [ value ].slice( noValue ) );
          }

        // For Promises/A+, convert exceptions into rejections
        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
        // Deferred#then to conditionally suppress rejection.
        } catch ( value ) {

          // Support: Android 4.0 only
          // Strict mode functions invoked without .call/.apply get global-object context
          reject.apply( undefined, [ value ] );
        }
      }

      jQuery.extend( {

        Deferred: function( func ) {
          var tuples = [

              // action, add listener, callbacks,
              // ... .then handlers, argument index, [final state]
              [ "notify", "progress", jQuery.Callbacks( "memory" ),
                jQuery.Callbacks( "memory" ), 2 ],
              [ "resolve", "done", jQuery.Callbacks( "once memory" ),
                jQuery.Callbacks( "once memory" ), 0, "resolved" ],
              [ "reject", "fail", jQuery.Callbacks( "once memory" ),
                jQuery.Callbacks( "once memory" ), 1, "rejected" ]
            ],
            state = "pending",
            promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done( arguments ).fail( arguments );
                return this;
              },
              "catch": function( fn ) {
                return promise.then( null, fn );
              },

              // Keep pipe for back-compat
              pipe: function( /* fnDone, fnFail, fnProgress */ ) {
                var fns = arguments;

                return jQuery.Deferred( function( newDefer ) {
                  jQuery.each( tuples, function( i, tuple ) {

                    // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                    var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

                    // deferred.progress(function() { bind to newDefer or newDefer.notify })
                    // deferred.done(function() { bind to newDefer or newDefer.resolve })
                    // deferred.fail(function() { bind to newDefer or newDefer.reject })
                    deferred[ tuple[ 1 ] ]( function() {
                      var returned = fn && fn.apply( this, arguments );
                      if ( returned && isFunction( returned.promise ) ) {
                        returned.promise()
                          .progress( newDefer.notify )
                          .done( newDefer.resolve )
                          .fail( newDefer.reject );
                      } else {
                        newDefer[ tuple[ 0 ] + "With" ](
                          this,
                          fn ? [ returned ] : arguments
                        );
                      }
                    } );
                  } );
                  fns = null;
                } ).promise();
              },
              then: function( onFulfilled, onRejected, onProgress ) {
                var maxDepth = 0;
                function resolve( depth, deferred, handler, special ) {
                  return function() {
                    var that = this,
                      args = arguments,
                      mightThrow = function() {
                        var returned, then;

                        // Support: Promises/A+ section 2.3.3.3.3
                        // https://promisesaplus.com/#point-59
                        // Ignore double-resolution attempts
                        if ( depth < maxDepth ) {
                          return;
                        }

                        returned = handler.apply( that, args );

                        // Support: Promises/A+ section 2.3.1
                        // https://promisesaplus.com/#point-48
                        if ( returned === deferred.promise() ) {
                          throw new TypeError( "Thenable self-resolution" );
                        }

                        // Support: Promises/A+ sections 2.3.3.1, 3.5
                        // https://promisesaplus.com/#point-54
                        // https://promisesaplus.com/#point-75
                        // Retrieve `then` only once
                        then = returned &&

                          // Support: Promises/A+ section 2.3.4
                          // https://promisesaplus.com/#point-64
                          // Only check objects and functions for thenability
                          ( typeof returned === "object" ||
                            typeof returned === "function" ) &&
                          returned.then;

                        // Handle a returned thenable
                        if ( isFunction( then ) ) {

                          // Special processors (notify) just wait for resolution
                          if ( special ) {
                            then.call(
                              returned,
                              resolve( maxDepth, deferred, Identity, special ),
                              resolve( maxDepth, deferred, Thrower, special )
                            );

                          // Normal processors (resolve) also hook into progress
                          } else {

                            // ...and disregard older resolution values
                            maxDepth++;

                            then.call(
                              returned,
                              resolve( maxDepth, deferred, Identity, special ),
                              resolve( maxDepth, deferred, Thrower, special ),
                              resolve( maxDepth, deferred, Identity,
                                deferred.notifyWith )
                            );
                          }

                        // Handle all other returned values
                        } else {

                          // Only substitute handlers pass on context
                          // and multiple values (non-spec behavior)
                          if ( handler !== Identity ) {
                            that = undefined;
                            args = [ returned ];
                          }

                          // Process the value(s)
                          // Default process is resolve
                          ( special || deferred.resolveWith )( that, args );
                        }
                      },

                      // Only normal processors (resolve) catch and reject exceptions
                      process = special ?
                        mightThrow :
                        function() {
                          try {
                            mightThrow();
                          } catch ( e ) {

                            if ( jQuery.Deferred.exceptionHook ) {
                              jQuery.Deferred.exceptionHook( e,
                                process.stackTrace );
                            }

                            // Support: Promises/A+ section 2.3.3.3.4.1
                            // https://promisesaplus.com/#point-61
                            // Ignore post-resolution exceptions
                            if ( depth + 1 >= maxDepth ) {

                              // Only substitute handlers pass on context
                              // and multiple values (non-spec behavior)
                              if ( handler !== Thrower ) {
                                that = undefined;
                                args = [ e ];
                              }

                              deferred.rejectWith( that, args );
                            }
                          }
                        };

                    // Support: Promises/A+ section 2.3.3.3.1
                    // https://promisesaplus.com/#point-57
                    // Re-resolve promises immediately to dodge false rejection from
                    // subsequent errors
                    if ( depth ) {
                      process();
                    } else {

                      // Call an optional hook to record the stack, in case of exception
                      // since it's otherwise lost when execution goes async
                      if ( jQuery.Deferred.getStackHook ) {
                        process.stackTrace = jQuery.Deferred.getStackHook();
                      }
                      window.setTimeout( process );
                    }
                  };
                }

                return jQuery.Deferred( function( newDefer ) {

                  // progress_handlers.add( ... )
                  tuples[ 0 ][ 3 ].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction( onProgress ) ?
                        onProgress :
                        Identity,
                      newDefer.notifyWith
                    )
                  );

                  // fulfilled_handlers.add( ... )
                  tuples[ 1 ][ 3 ].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction( onFulfilled ) ?
                        onFulfilled :
                        Identity
                    )
                  );

                  // rejected_handlers.add( ... )
                  tuples[ 2 ][ 3 ].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction( onRejected ) ?
                        onRejected :
                        Thrower
                    )
                  );
                } ).promise();
              },

              // Get a promise for this deferred
              // If obj is provided, the promise aspect is added to the object
              promise: function( obj ) {
                return obj != null ? jQuery.extend( obj, promise ) : promise;
              }
            },
            deferred = {};

          // Add list-specific methods
          jQuery.each( tuples, function( i, tuple ) {
            var list = tuple[ 2 ],
              stateString = tuple[ 5 ];

            // promise.progress = list.add
            // promise.done = list.add
            // promise.fail = list.add
            promise[ tuple[ 1 ] ] = list.add;

            // Handle state
            if ( stateString ) {
              list.add(
                function() {

                  // state = "resolved" (i.e., fulfilled)
                  // state = "rejected"
                  state = stateString;
                },

                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[ 3 - i ][ 2 ].disable,

                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[ 3 - i ][ 3 ].disable,

                // progress_callbacks.lock
                tuples[ 0 ][ 2 ].lock,

                // progress_handlers.lock
                tuples[ 0 ][ 3 ].lock
              );
            }

            // progress_handlers.fire
            // fulfilled_handlers.fire
            // rejected_handlers.fire
            list.add( tuple[ 3 ].fire );

            // deferred.notify = function() { deferred.notifyWith(...) }
            // deferred.resolve = function() { deferred.resolveWith(...) }
            // deferred.reject = function() { deferred.rejectWith(...) }
            deferred[ tuple[ 0 ] ] = function() {
              deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
              return this;
            };

            // deferred.notifyWith = list.fireWith
            // deferred.resolveWith = list.fireWith
            // deferred.rejectWith = list.fireWith
            deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
          } );

          // Make the deferred a promise
          promise.promise( deferred );

          // Call given func if any
          if ( func ) {
            func.call( deferred, deferred );
          }

          // All done!
          return deferred;
        },

        // Deferred helper
        when: function( singleValue ) {
          var

            // count of uncompleted subordinates
            remaining = arguments.length,

            // count of unprocessed arguments
            i = remaining,

            // subordinate fulfillment data
            resolveContexts = Array( i ),
            resolveValues = slice.call( arguments ),

            // the master Deferred
            master = jQuery.Deferred(),

            // subordinate callback factory
            updateFunc = function( i ) {
              return function( value ) {
                resolveContexts[ i ] = this;
                resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                if ( !( --remaining ) ) {
                  master.resolveWith( resolveContexts, resolveValues );
                }
              };
            };

          // Single- and empty arguments are adopted like Promise.resolve
          if ( remaining <= 1 ) {
            adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
              !remaining );

            // Use .then() to unwrap secondary thenables (cf. gh-3000)
            if ( master.state() === "pending" ||
              isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

              return master.then();
            }
          }

          // Multiple arguments are aggregated like Promise.all array elements
          while ( i-- ) {
            adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
          }

          return master.promise();
        }
      } );


      // These usually indicate a programmer mistake during development,
      // warn about them ASAP rather than swallowing them by default.
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

      jQuery.Deferred.exceptionHook = function( error, stack ) {

        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
          window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
        }
      };




      jQuery.readyException = function( error ) {
        window.setTimeout( function() {
          throw error;
        } );
      };




      // The deferred used on DOM ready
      var readyList = jQuery.Deferred();

      jQuery.fn.ready = function( fn ) {

        readyList
          .then( fn )

          // Wrap jQuery.readyException in a function so that the lookup
          // happens at the time of error handling instead of callback
          // registration.
          .catch( function( error ) {
            jQuery.readyException( error );
          } );

        return this;
      };

      jQuery.extend( {

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Handle when the DOM is ready
        ready: function( wait ) {

          // Abort if there are pending holds or we're already ready
          if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
            return;
          }

          // Remember that the DOM is ready
          jQuery.isReady = true;

          // If a normal DOM Ready event fired, decrement, and wait if need be
          if ( wait !== true && --jQuery.readyWait > 0 ) {
            return;
          }

          // If there are functions bound, to execute
          readyList.resolveWith( document, [ jQuery ] );
        }
      } );

      jQuery.ready.then = readyList.then;

      // The ready event handler and self cleanup method
      function completed() {
        document.removeEventListener( "DOMContentLoaded", completed );
        window.removeEventListener( "load", completed );
        jQuery.ready();
      }

      // Catch cases where $(document).ready() is called
      // after the browser event has already occurred.
      // Support: IE <=9 - 10 only
      // Older IE sometimes signals "interactive" too soon
      if ( document.readyState === "complete" ||
        ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

        // Handle it asynchronously to allow scripts the opportunity to delay ready
        window.setTimeout( jQuery.ready );

      } else {

        // Use the handy event callback
        document.addEventListener( "DOMContentLoaded", completed );

        // A fallback to window.onload, that will always work
        window.addEventListener( "load", completed );
      }




      // Multifunctional method to get and set values of a collection
      // The value/s can optionally be executed if it's a function
      var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
        var i = 0,
          len = elems.length,
          bulk = key == null;

        // Sets many values
        if ( toType( key ) === "object" ) {
          chainable = true;
          for ( i in key ) {
            access( elems, fn, i, key[ i ], true, emptyGet, raw );
          }

        // Sets one value
        } else if ( value !== undefined ) {
          chainable = true;

          if ( !isFunction( value ) ) {
            raw = true;
          }

          if ( bulk ) {

            // Bulk operations run against the entire set
            if ( raw ) {
              fn.call( elems, value );
              fn = null;

            // ...except when executing function values
            } else {
              bulk = fn;
              fn = function( elem, key, value ) {
                return bulk.call( jQuery( elem ), value );
              };
            }
          }

          if ( fn ) {
            for ( ; i < len; i++ ) {
              fn(
                elems[ i ], key, raw ?
                value :
                value.call( elems[ i ], i, fn( elems[ i ], key ) )
              );
            }
          }
        }

        if ( chainable ) {
          return elems;
        }

        // Gets
        if ( bulk ) {
          return fn.call( elems );
        }

        return len ? fn( elems[ 0 ], key ) : emptyGet;
      };


      // Matches dashed string for camelizing
      var rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g;

      // Used by camelCase as callback to replace()
      function fcamelCase( all, letter ) {
        return letter.toUpperCase();
      }

      // Convert dashed to camelCase; used by the css and data modules
      // Support: IE <=9 - 11, Edge 12 - 15
      // Microsoft forgot to hump their vendor prefix (#9572)
      function camelCase( string ) {
        return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
      }
      var acceptData = function( owner ) {

        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
      };




      function Data() {
        this.expando = jQuery.expando + Data.uid++;
      }

      Data.uid = 1;

      Data.prototype = {

        cache: function( owner ) {

          // Check if the owner object already has a cache
          var value = owner[ this.expando ];

          // If not, create one
          if ( !value ) {
            value = {};

            // We can accept data for non-element nodes in modern browsers,
            // but we should not, see #8335.
            // Always return an empty object.
            if ( acceptData( owner ) ) {

              // If it is a node unlikely to be stringify-ed or looped over
              // use plain assignment
              if ( owner.nodeType ) {
                owner[ this.expando ] = value;

              // Otherwise secure it in a non-enumerable property
              // configurable must be true to allow the property to be
              // deleted when data is removed
              } else {
                Object.defineProperty( owner, this.expando, {
                  value: value,
                  configurable: true
                } );
              }
            }
          }

          return value;
        },
        set: function( owner, data, value ) {
          var prop,
            cache = this.cache( owner );

          // Handle: [ owner, key, value ] args
          // Always use camelCase key (gh-2257)
          if ( typeof data === "string" ) {
            cache[ camelCase( data ) ] = value;

          // Handle: [ owner, { properties } ] args
          } else {

            // Copy the properties one-by-one to the cache object
            for ( prop in data ) {
              cache[ camelCase( prop ) ] = data[ prop ];
            }
          }
          return cache;
        },
        get: function( owner, key ) {
          return key === undefined ?
            this.cache( owner ) :

            // Always use camelCase key (gh-2257)
            owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
        },
        access: function( owner, key, value ) {

          // In cases where either:
          //
          //   1. No key was specified
          //   2. A string key was specified, but no value provided
          //
          // Take the "read" path and allow the get method to determine
          // which value to return, respectively either:
          //
          //   1. The entire cache object
          //   2. The data stored at the key
          //
          if ( key === undefined ||
              ( ( key && typeof key === "string" ) && value === undefined ) ) {

            return this.get( owner, key );
          }

          // When the key is not a string, or both a key and value
          // are specified, set or extend (existing objects) with either:
          //
          //   1. An object of properties
          //   2. A key and value
          //
          this.set( owner, key, value );

          // Since the "set" path can have two possible entry points
          // return the expected data based on which path was taken[*]
          return value !== undefined ? value : key;
        },
        remove: function( owner, key ) {
          var i,
            cache = owner[ this.expando ];

          if ( cache === undefined ) {
            return;
          }

          if ( key !== undefined ) {

            // Support array or space separated string of keys
            if ( Array.isArray( key ) ) {

              // If key is an array of keys...
              // We always set camelCase keys, so remove that.
              key = key.map( camelCase );
            } else {
              key = camelCase( key );

              // If a key with the spaces exists, use it.
              // Otherwise, create an array by matching non-whitespace
              key = key in cache ?
                [ key ] :
                ( key.match( rnothtmlwhite ) || [] );
            }

            i = key.length;

            while ( i-- ) {
              delete cache[ key[ i ] ];
            }
          }

          // Remove the expando if there's no more data
          if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

            // Support: Chrome <=35 - 45
            // Webkit & Blink performance suffers when deleting properties
            // from DOM nodes, so set to undefined instead
            // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
            if ( owner.nodeType ) {
              owner[ this.expando ] = undefined;
            } else {
              delete owner[ this.expando ];
            }
          }
        },
        hasData: function( owner ) {
          var cache = owner[ this.expando ];
          return cache !== undefined && !jQuery.isEmptyObject( cache );
        }
      };
      var dataPriv = new Data();

      var dataUser = new Data();



      //  Implementation Summary
      //
      //  1. Enforce API surface and semantic compatibility with 1.9.x branch
      //  2. Improve the module's maintainability by reducing the storage
      //    paths to a single mechanism.
      //  3. Use the same single mechanism to support "private" and "user" data.
      //  4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
      //  5. Avoid exposing implementation details on user objects (eg. expando properties)
      //  6. Provide a clear path for implementation upgrade to WeakMap in 2014

      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

      function getData( data ) {
        if ( data === "true" ) {
          return true;
        }

        if ( data === "false" ) {
          return false;
        }

        if ( data === "null" ) {
          return null;
        }

        // Only convert to a number if it doesn't change the string
        if ( data === +data + "" ) {
          return +data;
        }

        if ( rbrace.test( data ) ) {
          return JSON.parse( data );
        }

        return data;
      }

      function dataAttr( elem, key, data ) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if ( data === undefined && elem.nodeType === 1 ) {
          name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
          data = elem.getAttribute( name );

          if ( typeof data === "string" ) {
            try {
              data = getData( data );
            } catch ( e ) {}

            // Make sure we set the data so it isn't changed later
            dataUser.set( elem, key, data );
          } else {
            data = undefined;
          }
        }
        return data;
      }

      jQuery.extend( {
        hasData: function( elem ) {
          return dataUser.hasData( elem ) || dataPriv.hasData( elem );
        },

        data: function( elem, name, data ) {
          return dataUser.access( elem, name, data );
        },

        removeData: function( elem, name ) {
          dataUser.remove( elem, name );
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function( elem, name, data ) {
          return dataPriv.access( elem, name, data );
        },

        _removeData: function( elem, name ) {
          dataPriv.remove( elem, name );
        }
      } );

      jQuery.fn.extend( {
        data: function( key, value ) {
          var i, name, data,
            elem = this[ 0 ],
            attrs = elem && elem.attributes;

          // Gets all values
          if ( key === undefined ) {
            if ( this.length ) {
              data = dataUser.get( elem );

              if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
                i = attrs.length;
                while ( i-- ) {

                  // Support: IE 11 only
                  // The attrs elements can be null (#14894)
                  if ( attrs[ i ] ) {
                    name = attrs[ i ].name;
                    if ( name.indexOf( "data-" ) === 0 ) {
                      name = camelCase( name.slice( 5 ) );
                      dataAttr( elem, name, data[ name ] );
                    }
                  }
                }
                dataPriv.set( elem, "hasDataAttrs", true );
              }
            }

            return data;
          }

          // Sets multiple values
          if ( typeof key === "object" ) {
            return this.each( function() {
              dataUser.set( this, key );
            } );
          }

          return access( this, function( value ) {
            var data;

            // The calling jQuery object (element matches) is not empty
            // (and therefore has an element appears at this[ 0 ]) and the
            // `value` parameter was not undefined. An empty jQuery object
            // will result in `undefined` for elem = this[ 0 ] which will
            // throw an exception if an attempt to read a data cache is made.
            if ( elem && value === undefined ) {

              // Attempt to get data from the cache
              // The key will always be camelCased in Data
              data = dataUser.get( elem, key );
              if ( data !== undefined ) {
                return data;
              }

              // Attempt to "discover" the data in
              // HTML5 custom data-* attrs
              data = dataAttr( elem, key );
              if ( data !== undefined ) {
                return data;
              }

              // We tried really hard, but the data doesn't exist.
              return;
            }

            // Set the data...
            this.each( function() {

              // We always store the camelCased key
              dataUser.set( this, key, value );
            } );
          }, null, value, arguments.length > 1, null, true );
        },

        removeData: function( key ) {
          return this.each( function() {
            dataUser.remove( this, key );
          } );
        }
      } );


      jQuery.extend( {
        queue: function( elem, type, data ) {
          var queue;

          if ( elem ) {
            type = ( type || "fx" ) + "queue";
            queue = dataPriv.get( elem, type );

            // Speed up dequeue by getting out quickly if this is just a lookup
            if ( data ) {
              if ( !queue || Array.isArray( data ) ) {
                queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
              } else {
                queue.push( data );
              }
            }
            return queue || [];
          }
        },

        dequeue: function( elem, type ) {
          type = type || "fx";

          var queue = jQuery.queue( elem, type ),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery._queueHooks( elem, type ),
            next = function() {
              jQuery.dequeue( elem, type );
            };

          // If the fx queue is dequeued, always remove the progress sentinel
          if ( fn === "inprogress" ) {
            fn = queue.shift();
            startLength--;
          }

          if ( fn ) {

            // Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            if ( type === "fx" ) {
              queue.unshift( "inprogress" );
            }

            // Clear up the last queue stop function
            delete hooks.stop;
            fn.call( elem, next, hooks );
          }

          if ( !startLength && hooks ) {
            hooks.empty.fire();
          }
        },

        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function( elem, type ) {
          var key = type + "queueHooks";
          return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
            empty: jQuery.Callbacks( "once memory" ).add( function() {
              dataPriv.remove( elem, [ type + "queue", key ] );
            } )
          } );
        }
      } );

      jQuery.fn.extend( {
        queue: function( type, data ) {
          var setter = 2;

          if ( typeof type !== "string" ) {
            data = type;
            type = "fx";
            setter--;
          }

          if ( arguments.length < setter ) {
            return jQuery.queue( this[ 0 ], type );
          }

          return data === undefined ?
            this :
            this.each( function() {
              var queue = jQuery.queue( this, type, data );

              // Ensure a hooks for this queue
              jQuery._queueHooks( this, type );

              if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
                jQuery.dequeue( this, type );
              }
            } );
        },
        dequeue: function( type ) {
          return this.each( function() {
            jQuery.dequeue( this, type );
          } );
        },
        clearQueue: function( type ) {
          return this.queue( type || "fx", [] );
        },

        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function( type, obj ) {
          var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function() {
              if ( !( --count ) ) {
                defer.resolveWith( elements, [ elements ] );
              }
            };

          if ( typeof type !== "string" ) {
            obj = type;
            type = undefined;
          }
          type = type || "fx";

          while ( i-- ) {
            tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
            if ( tmp && tmp.empty ) {
              count++;
              tmp.empty.add( resolve );
            }
          }
          resolve();
          return defer.promise( obj );
        }
      } );
      var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

      var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


      var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

      var documentElement = document.documentElement;



        var isAttached = function( elem ) {
            return jQuery.contains( elem.ownerDocument, elem );
          },
          composed = { composed: true };

        // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
        // Check attachment across shadow DOM boundaries when possible (gh-3504)
        // Support: iOS 10.0-10.2 only
        // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
        // leading to errors. We need to check for `getRootNode`.
        if ( documentElement.getRootNode ) {
          isAttached = function( elem ) {
            return jQuery.contains( elem.ownerDocument, elem ) ||
              elem.getRootNode( composed ) === elem.ownerDocument;
          };
        }
      var isHiddenWithinTree = function( elem, el ) {

          // isHiddenWithinTree might be called from jQuery#filter function;
          // in that case, element will be second argument
          elem = el || elem;

          // Inline style trumps all
          return elem.style.display === "none" ||
            elem.style.display === "" &&

            // Otherwise, check computed style
            // Support: Firefox <=43 - 45
            // Disconnected elements can have computed display: none, so first confirm that elem is
            // in the document.
            isAttached( elem ) &&

            jQuery.css( elem, "display" ) === "none";
        };

      var swap = function( elem, options, callback, args ) {
        var ret, name,
          old = {};

        // Remember the old values, and insert the new ones
        for ( name in options ) {
          old[ name ] = elem.style[ name ];
          elem.style[ name ] = options[ name ];
        }

        ret = callback.apply( elem, args || [] );

        // Revert the old values
        for ( name in options ) {
          elem.style[ name ] = old[ name ];
        }

        return ret;
      };




      function adjustCSS( elem, prop, valueParts, tween ) {
        var adjusted, scale,
          maxIterations = 20,
          currentValue = tween ?
            function() {
              return tween.cur();
            } :
            function() {
              return jQuery.css( elem, prop, "" );
            },
          initial = currentValue(),
          unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

          // Starting value computation is required for potential unit mismatches
          initialInUnit = elem.nodeType &&
            ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
            rcssNum.exec( jQuery.css( elem, prop ) );

        if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

          // Support: Firefox <=54
          // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
          initial = initial / 2;

          // Trust units reported by jQuery.css
          unit = unit || initialInUnit[ 3 ];

          // Iteratively approximate from a nonzero starting point
          initialInUnit = +initial || 1;

          while ( maxIterations-- ) {

            // Evaluate and update our best guess (doubling guesses that zero out).
            // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
            jQuery.style( elem, prop, initialInUnit + unit );
            if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;

          }

          initialInUnit = initialInUnit * 2;
          jQuery.style( elem, prop, initialInUnit + unit );

          // Make sure we update the tween properties later on
          valueParts = valueParts || [];
        }

        if ( valueParts ) {
          initialInUnit = +initialInUnit || +initial || 0;

          // Apply relative offset (+=/-=) if specified
          adjusted = valueParts[ 1 ] ?
            initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
            +valueParts[ 2 ];
          if ( tween ) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }


      var defaultDisplayMap = {};

      function getDefaultDisplay( elem ) {
        var temp,
          doc = elem.ownerDocument,
          nodeName = elem.nodeName,
          display = defaultDisplayMap[ nodeName ];

        if ( display ) {
          return display;
        }

        temp = doc.body.appendChild( doc.createElement( nodeName ) );
        display = jQuery.css( temp, "display" );

        temp.parentNode.removeChild( temp );

        if ( display === "none" ) {
          display = "block";
        }
        defaultDisplayMap[ nodeName ] = display;

        return display;
      }

      function showHide( elements, show ) {
        var display, elem,
          values = [],
          index = 0,
          length = elements.length;

        // Determine new display value for elements that need to change
        for ( ; index < length; index++ ) {
          elem = elements[ index ];
          if ( !elem.style ) {
            continue;
          }

          display = elem.style.display;
          if ( show ) {

            // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
            // check is required in this first loop unless we have a nonempty display value (either
            // inline or about-to-be-restored)
            if ( display === "none" ) {
              values[ index ] = dataPriv.get( elem, "display" ) || null;
              if ( !values[ index ] ) {
                elem.style.display = "";
              }
            }
            if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
              values[ index ] = getDefaultDisplay( elem );
            }
          } else {
            if ( display !== "none" ) {
              values[ index ] = "none";

              // Remember what we're overwriting
              dataPriv.set( elem, "display", display );
            }
          }
        }

        // Set the display of the elements in a second loop to avoid constant reflow
        for ( index = 0; index < length; index++ ) {
          if ( values[ index ] != null ) {
            elements[ index ].style.display = values[ index ];
          }
        }

        return elements;
      }

      jQuery.fn.extend( {
        show: function() {
          return showHide( this, true );
        },
        hide: function() {
          return showHide( this );
        },
        toggle: function( state ) {
          if ( typeof state === "boolean" ) {
            return state ? this.show() : this.hide();
          }

          return this.each( function() {
            if ( isHiddenWithinTree( this ) ) {
              jQuery( this ).show();
            } else {
              jQuery( this ).hide();
            }
          } );
        }
      } );
      var rcheckableType = ( /^(?:checkbox|radio)$/i );

      var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

      var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



      // We have to close these tags to support XHTML (#13200)
      var wrapMap = {

        // Support: IE <=9 only
        option: [ 1, "<select multiple='multiple'>", "</select>" ],

        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

        _default: [ 0, "", "" ]
      };

      // Support: IE <=9 only
      wrapMap.optgroup = wrapMap.option;

      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;


      function getAll( context, tag ) {

        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;

        if ( typeof context.getElementsByTagName !== "undefined" ) {
          ret = context.getElementsByTagName( tag || "*" );

        } else if ( typeof context.querySelectorAll !== "undefined" ) {
          ret = context.querySelectorAll( tag || "*" );

        } else {
          ret = [];
        }

        if ( tag === undefined || tag && nodeName( context, tag ) ) {
          return jQuery.merge( [ context ], ret );
        }

        return ret;
      }


      // Mark scripts as having already been evaluated
      function setGlobalEval( elems, refElements ) {
        var i = 0,
          l = elems.length;

        for ( ; i < l; i++ ) {
          dataPriv.set(
            elems[ i ],
            "globalEval",
            !refElements || dataPriv.get( refElements[ i ], "globalEval" )
          );
        }
      }


      var rhtml = /<|&#?\w+;/;

      function buildFragment( elems, context, scripts, selection, ignored ) {
        var elem, tmp, tag, wrap, attached, j,
          fragment = context.createDocumentFragment(),
          nodes = [],
          i = 0,
          l = elems.length;

        for ( ; i < l; i++ ) {
          elem = elems[ i ];

          if ( elem || elem === 0 ) {

            // Add nodes directly
            if ( toType( elem ) === "object" ) {

              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

            // Convert non-html into a text node
            } else if ( !rhtml.test( elem ) ) {
              nodes.push( context.createTextNode( elem ) );

            // Convert html into DOM nodes
            } else {
              tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

              // Deserialize a standard representation
              tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
              wrap = wrapMap[ tag ] || wrapMap._default;
              tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

              // Descend through wrappers to the right content
              j = wrap[ 0 ];
              while ( j-- ) {
                tmp = tmp.lastChild;
              }

              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge( nodes, tmp.childNodes );

              // Remember the top-level container
              tmp = fragment.firstChild;

              // Ensure the created nodes are orphaned (#12392)
              tmp.textContent = "";
            }
          }
        }

        // Remove wrapper from fragment
        fragment.textContent = "";

        i = 0;
        while ( ( elem = nodes[ i++ ] ) ) {

          // Skip elements already in the context collection (trac-4087)
          if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
            if ( ignored ) {
              ignored.push( elem );
            }
            continue;
          }

          attached = isAttached( elem );

          // Append to fragment
          tmp = getAll( fragment.appendChild( elem ), "script" );

          // Preserve script evaluation history
          if ( attached ) {
            setGlobalEval( tmp );
          }

          // Capture executables
          if ( scripts ) {
            j = 0;
            while ( ( elem = tmp[ j++ ] ) ) {
              if ( rscriptType.test( elem.type || "" ) ) {
                scripts.push( elem );
              }
            }
          }
        }

        return fragment;
      }


      ( function() {
        var fragment = document.createDocumentFragment(),
          div = fragment.appendChild( document.createElement( "div" ) ),
          input = document.createElement( "input" );

        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute( "type", "radio" );
        input.setAttribute( "checked", "checked" );
        input.setAttribute( "name", "t" );

        div.appendChild( input );

        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
      } )();


      var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

      function returnTrue() {
        return true;
      }

      function returnFalse() {
        return false;
      }

      // Support: IE <=9 - 11+
      // focus() and blur() are asynchronous, except when they are no-op.
      // So expect focus to be synchronous when the element is already active,
      // and blur to be synchronous when the element is not already active.
      // (focus and blur are always synchronous in other supported browsers,
      // this just defines when we can count on it).
      function expectSync( elem, type ) {
        return ( elem === safeActiveElement() ) === ( type === "focus" );
      }

      // Support: IE <=9 only
      // Accessing document.activeElement can throw unexpectedly
      // https://bugs.jquery.com/ticket/13393
      function safeActiveElement() {
        try {
          return document.activeElement;
        } catch ( err ) { }
      }

      function on( elem, types, selector, data, fn, one ) {
        var origFn, type;

        // Types can be a map of types/handlers
        if ( typeof types === "object" ) {

          // ( types-Object, selector, data )
          if ( typeof selector !== "string" ) {

            // ( types-Object, data )
            data = data || selector;
            selector = undefined;
          }
          for ( type in types ) {
            on( elem, type, selector, data, types[ type ], one );
          }
          return elem;
        }

        if ( data == null && fn == null ) {

          // ( types, fn )
          fn = selector;
          data = selector = undefined;
        } else if ( fn == null ) {
          if ( typeof selector === "string" ) {

            // ( types, selector, fn )
            fn = data;
            data = undefined;
          } else {

            // ( types, data, fn )
            fn = data;
            data = selector;
            selector = undefined;
          }
        }
        if ( fn === false ) {
          fn = returnFalse;
        } else if ( !fn ) {
          return elem;
        }

        if ( one === 1 ) {
          origFn = fn;
          fn = function( event ) {

            // Can use an empty set, since event contains the info
            jQuery().off( event );
            return origFn.apply( this, arguments );
          };

          // Use same guid so caller can remove using origFn
          fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return elem.each( function() {
          jQuery.event.add( this, types, fn, data, selector );
        } );
      }

      /*
       * Helper functions for managing events -- not part of the public interface.
       * Props to Dean Edwards' addEvent library for many of the ideas.
       */
      jQuery.event = {

        global: {},

        add: function( elem, types, handler, data, selector ) {

          var handleObjIn, eventHandle, tmp,
            events, t, handleObj,
            special, handlers, type, namespaces, origType,
            elemData = dataPriv.get( elem );

          // Don't attach events to noData or text/comment nodes (but allow plain objects)
          if ( !elemData ) {
            return;
          }

          // Caller can pass in an object of custom data in lieu of the handler
          if ( handler.handler ) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }

          // Ensure that invalid selectors throw exceptions at attach time
          // Evaluate against documentElement in case elem is a non-element node (e.g., document)
          if ( selector ) {
            jQuery.find.matchesSelector( documentElement, selector );
          }

          // Make sure that the handler has a unique ID, used to find/remove it later
          if ( !handler.guid ) {
            handler.guid = jQuery.guid++;
          }

          // Init the element's event structure and main handler, if this is the first
          if ( !( events = elemData.events ) ) {
            events = elemData.events = {};
          }
          if ( !( eventHandle = elemData.handle ) ) {
            eventHandle = elemData.handle = function( e ) {

              // Discard the second event of a jQuery.event.trigger() and
              // when an event is called after a page has unloaded
              return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                jQuery.event.dispatch.apply( elem, arguments ) : undefined;
            };
          }

          // Handle multiple events separated by a space
          types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
          t = types.length;
          while ( t-- ) {
            tmp = rtypenamespace.exec( types[ t ] ) || [];
            type = origType = tmp[ 1 ];
            namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

            // There *must* be a type, no attaching namespace-only handlers
            if ( !type ) {
              continue;
            }

            // If event changes its type, use the special event handlers for the changed type
            special = jQuery.event.special[ type ] || {};

            // If selector defined, determine special event api type, otherwise given type
            type = ( selector ? special.delegateType : special.bindType ) || type;

            // Update special based on newly reset type
            special = jQuery.event.special[ type ] || {};

            // handleObj is passed to all event handlers
            handleObj = jQuery.extend( {
              type: type,
              origType: origType,
              data: data,
              handler: handler,
              guid: handler.guid,
              selector: selector,
              needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
              namespace: namespaces.join( "." )
            }, handleObjIn );

            // Init the event handler queue if we're the first
            if ( !( handlers = events[ type ] ) ) {
              handlers = events[ type ] = [];
              handlers.delegateCount = 0;

              // Only use addEventListener if the special events handler returns false
              if ( !special.setup ||
                special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

                if ( elem.addEventListener ) {
                  elem.addEventListener( type, eventHandle );
                }
              }
            }

            if ( special.add ) {
              special.add.call( elem, handleObj );

              if ( !handleObj.handler.guid ) {
                handleObj.handler.guid = handler.guid;
              }
            }

            // Add to the element's handler list, delegates in front
            if ( selector ) {
              handlers.splice( handlers.delegateCount++, 0, handleObj );
            } else {
              handlers.push( handleObj );
            }

            // Keep track of which events have ever been used, for event optimization
            jQuery.event.global[ type ] = true;
          }

        },

        // Detach an event or set of events from an element
        remove: function( elem, types, handler, selector, mappedTypes ) {

          var j, origCount, tmp,
            events, t, handleObj,
            special, handlers, type, namespaces, origType,
            elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

          if ( !elemData || !( events = elemData.events ) ) {
            return;
          }

          // Once for each type.namespace in types; type may be omitted
          types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
          t = types.length;
          while ( t-- ) {
            tmp = rtypenamespace.exec( types[ t ] ) || [];
            type = origType = tmp[ 1 ];
            namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

            // Unbind all events (on this namespace, if provided) for the element
            if ( !type ) {
              for ( type in events ) {
                jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
              }
              continue;
            }

            special = jQuery.event.special[ type ] || {};
            type = ( selector ? special.delegateType : special.bindType ) || type;
            handlers = events[ type ] || [];
            tmp = tmp[ 2 ] &&
              new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

            // Remove matching events
            origCount = j = handlers.length;
            while ( j-- ) {
              handleObj = handlers[ j ];

              if ( ( mappedTypes || origType === handleObj.origType ) &&
                ( !handler || handler.guid === handleObj.guid ) &&
                ( !tmp || tmp.test( handleObj.namespace ) ) &&
                ( !selector || selector === handleObj.selector ||
                  selector === "**" && handleObj.selector ) ) {
                handlers.splice( j, 1 );

                if ( handleObj.selector ) {
                  handlers.delegateCount--;
                }
                if ( special.remove ) {
                  special.remove.call( elem, handleObj );
                }
              }
            }

            // Remove generic event handler if we removed something and no more handlers exist
            // (avoids potential for endless recursion during removal of special event handlers)
            if ( origCount && !handlers.length ) {
              if ( !special.teardown ||
                special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

                jQuery.removeEvent( elem, type, elemData.handle );
              }

              delete events[ type ];
            }
          }

          // Remove data and the expando if it's no longer used
          if ( jQuery.isEmptyObject( events ) ) {
            dataPriv.remove( elem, "handle events" );
          }
        },

        dispatch: function( nativeEvent ) {

          // Make a writable jQuery.Event from the native event object
          var event = jQuery.event.fix( nativeEvent );

          var i, j, ret, matched, handleObj, handlerQueue,
            args = new Array( arguments.length ),
            handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
            special = jQuery.event.special[ event.type ] || {};

          // Use the fix-ed jQuery.Event rather than the (read-only) native event
          args[ 0 ] = event;

          for ( i = 1; i < arguments.length; i++ ) {
            args[ i ] = arguments[ i ];
          }

          event.delegateTarget = this;

          // Call the preDispatch hook for the mapped type, and let it bail if desired
          if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
            return;
          }

          // Determine handlers
          handlerQueue = jQuery.event.handlers.call( this, event, handlers );

          // Run delegates first; they may want to stop propagation beneath us
          i = 0;
          while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
            event.currentTarget = matched.elem;

            j = 0;
            while ( ( handleObj = matched.handlers[ j++ ] ) &&
              !event.isImmediatePropagationStopped() ) {

              // If the event is namespaced, then each handler is only invoked if it is
              // specially universal or its namespaces are a superset of the event's.
              if ( !event.rnamespace || handleObj.namespace === false ||
                event.rnamespace.test( handleObj.namespace ) ) {

                event.handleObj = handleObj;
                event.data = handleObj.data;

                ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
                  handleObj.handler ).apply( matched.elem, args );

                if ( ret !== undefined ) {
                  if ( ( event.result = ret ) === false ) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }

          // Call the postDispatch hook for the mapped type
          if ( special.postDispatch ) {
            special.postDispatch.call( this, event );
          }

          return event.result;
        },

        handlers: function( event, handlers ) {
          var i, handleObj, sel, matchedHandlers, matchedSelectors,
            handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = event.target;

          // Find delegate handlers
          if ( delegateCount &&

            // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType &&

            // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !( event.type === "click" && event.button >= 1 ) ) {

            for ( ; cur !== this; cur = cur.parentNode || this ) {

              // Don't check non-elements (#13208)
              // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
              if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
                matchedHandlers = [];
                matchedSelectors = {};
                for ( i = 0; i < delegateCount; i++ ) {
                  handleObj = handlers[ i ];

                  // Don't conflict with Object.prototype properties (#13203)
                  sel = handleObj.selector + " ";

                  if ( matchedSelectors[ sel ] === undefined ) {
                    matchedSelectors[ sel ] = handleObj.needsContext ?
                      jQuery( sel, this ).index( cur ) > -1 :
                      jQuery.find( sel, this, null, [ cur ] ).length;
                  }
                  if ( matchedSelectors[ sel ] ) {
                    matchedHandlers.push( handleObj );
                  }
                }
                if ( matchedHandlers.length ) {
                  handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
                }
              }
            }
          }

          // Add the remaining (directly-bound) handlers
          cur = this;
          if ( delegateCount < handlers.length ) {
            handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
          }

          return handlerQueue;
        },

        addProp: function( name, hook ) {
          Object.defineProperty( jQuery.Event.prototype, name, {
            enumerable: true,
            configurable: true,

            get: isFunction( hook ) ?
              function() {
                if ( this.originalEvent ) {
                    return hook( this.originalEvent );
                }
              } :
              function() {
                if ( this.originalEvent ) {
                    return this.originalEvent[ name ];
                }
              },

            set: function( value ) {
              Object.defineProperty( this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value: value
              } );
            }
          } );
        },

        fix: function( originalEvent ) {
          return originalEvent[ jQuery.expando ] ?
            originalEvent :
            new jQuery.Event( originalEvent );
        },

        special: {
          load: {

            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {

            // Utilize native event to ensure correct state for checkable inputs
            setup: function( data ) {

              // For mutual compressibility with _default, replace `this` access with a local var.
              // `|| data` is dead code meant only to preserve the variable through minification.
              var el = this || data;

              // Claim the first handler
              if ( rcheckableType.test( el.type ) &&
                el.click && nodeName( el, "input" ) ) {

                // dataPriv.set( el, "click", ... )
                leverageNative( el, "click", returnTrue );
              }

              // Return false to allow normal processing in the caller
              return false;
            },
            trigger: function( data ) {

              // For mutual compressibility with _default, replace `this` access with a local var.
              // `|| data` is dead code meant only to preserve the variable through minification.
              var el = this || data;

              // Force setup before triggering a click
              if ( rcheckableType.test( el.type ) &&
                el.click && nodeName( el, "input" ) ) {

                leverageNative( el, "click" );
              }

              // Return non-false to allow normal event-path propagation
              return true;
            },

            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function( event ) {
              var target = event.target;
              return rcheckableType.test( target.type ) &&
                target.click && nodeName( target, "input" ) &&
                dataPriv.get( target, "click" ) ||
                nodeName( target, "a" );
            }
          },

          beforeunload: {
            postDispatch: function( event ) {

              // Support: Firefox 20+
              // Firefox doesn't alert if the returnValue field is not set.
              if ( event.result !== undefined && event.originalEvent ) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      };

      // Ensure the presence of an event listener that handles manually-triggered
      // synthetic events by interrupting progress until reinvoked in response to
      // *native* events that it fires directly, ensuring that state changes have
      // already occurred before other listeners are invoked.
      function leverageNative( el, type, expectSync ) {

        // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
        if ( !expectSync ) {
          if ( dataPriv.get( el, type ) === undefined ) {
            jQuery.event.add( el, type, returnTrue );
          }
          return;
        }

        // Register the controller as a special universal handler for all event namespaces
        dataPriv.set( el, type, false );
        jQuery.event.add( el, type, {
          namespace: false,
          handler: function( event ) {
            var notAsync, result,
              saved = dataPriv.get( this, type );

            if ( ( event.isTrigger & 1 ) && this[ type ] ) {

              // Interrupt processing of the outer synthetic .trigger()ed event
              // Saved data should be false in such cases, but might be a leftover capture object
              // from an async native handler (gh-4350)
              if ( !saved.length ) {

                // Store arguments for use when handling the inner native event
                // There will always be at least one argument (an event object), so this array
                // will not be confused with a leftover capture object.
                saved = slice.call( arguments );
                dataPriv.set( this, type, saved );

                // Trigger the native event and capture its result
                // Support: IE <=9 - 11+
                // focus() and blur() are asynchronous
                notAsync = expectSync( this, type );
                this[ type ]();
                result = dataPriv.get( this, type );
                if ( saved !== result || notAsync ) {
                  dataPriv.set( this, type, false );
                } else {
                  result = {};
                }
                if ( saved !== result ) {

                  // Cancel the outer synthetic event
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result.value;
                }

              // If this is an inner synthetic event for an event with a bubbling surrogate
              // (focus or blur), assume that the surrogate already propagated from triggering the
              // native event and prevent that from happening again here.
              // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
              // bubbling surrogate propagates *after* the non-bubbling base), but that seems
              // less bad than duplication.
              } else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
                event.stopPropagation();
              }

            // If this is a native event triggered above, everything is now in order
            // Fire an inner synthetic event with the original arguments
            } else if ( saved.length ) {

              // ...and capture the result
              dataPriv.set( this, type, {
                value: jQuery.event.trigger(

                  // Support: IE <=9 - 11+
                  // Extend with the prototype to reset the above stopImmediatePropagation()
                  jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
                  saved.slice( 1 ),
                  this
                )
              } );

              // Abort handling of the native event
              event.stopImmediatePropagation();
            }
          }
        } );
      }

      jQuery.removeEvent = function( elem, type, handle ) {

        // This "if" is needed for plain objects
        if ( elem.removeEventListener ) {
          elem.removeEventListener( type, handle );
        }
      };

      jQuery.Event = function( src, props ) {

        // Allow instantiation without the 'new' keyword
        if ( !( this instanceof jQuery.Event ) ) {
          return new jQuery.Event( src, props );
        }

        // Event object
        if ( src && src.type ) {
          this.originalEvent = src;
          this.type = src.type;

          // Events bubbling up the document may have been marked as prevented
          // by a handler lower down the tree; reflect the correct value.
          this.isDefaultPrevented = src.defaultPrevented ||
              src.defaultPrevented === undefined &&

              // Support: Android <=2.3 only
              src.returnValue === false ?
            returnTrue :
            returnFalse;

          // Create target properties
          // Support: Safari <=6 - 7 only
          // Target should not be a text node (#504, #13143)
          this.target = ( src.target && src.target.nodeType === 3 ) ?
            src.target.parentNode :
            src.target;

          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;

        // Event type
        } else {
          this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if ( props ) {
          jQuery.extend( this, props );
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();

        // Mark it as fixed
        this[ jQuery.expando ] = true;
      };

      // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
      // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
      jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,

        preventDefault: function() {
          var e = this.originalEvent;

          this.isDefaultPrevented = returnTrue;

          if ( e && !this.isSimulated ) {
            e.preventDefault();
          }
        },
        stopPropagation: function() {
          var e = this.originalEvent;

          this.isPropagationStopped = returnTrue;

          if ( e && !this.isSimulated ) {
            e.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e = this.originalEvent;

          this.isImmediatePropagationStopped = returnTrue;

          if ( e && !this.isSimulated ) {
            e.stopImmediatePropagation();
          }

          this.stopPropagation();
        }
      };

      // Includes all common event props including KeyEvent and MouseEvent specific props
      jQuery.each( {
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,

        which: function( event ) {
          var button = event.button;

          // Add which for key events
          if ( event.which == null && rkeyEvent.test( event.type ) ) {
            return event.charCode != null ? event.charCode : event.keyCode;
          }

          // Add which for click: 1 === left; 2 === middle; 3 === right
          if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
            if ( button & 1 ) {
              return 1;
            }

            if ( button & 2 ) {
              return 3;
            }

            if ( button & 4 ) {
              return 2;
            }

            return 0;
          }

          return event.which;
        }
      }, jQuery.event.addProp );

      jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
        jQuery.event.special[ type ] = {

          // Utilize native event if possible so blur/focus sequence is correct
          setup: function() {

            // Claim the first handler
            // dataPriv.set( this, "focus", ... )
            // dataPriv.set( this, "blur", ... )
            leverageNative( this, type, expectSync );

            // Return false to allow normal processing in the caller
            return false;
          },
          trigger: function() {

            // Force setup before trigger
            leverageNative( this, type );

            // Return non-false to allow normal event-path propagation
            return true;
          },

          delegateType: delegateType
        };
      } );

      // Create mouseenter/leave events using mouseover/out and event-time checks
      // so that event delegation works in jQuery.
      // Do the same for pointerenter/pointerleave and pointerover/pointerout
      //
      // Support: Safari 7 only
      // Safari sends mouseenter too often; see:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
      // for the description of the bug (it existed in older Chrome versions as well).
      jQuery.each( {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function( orig, fix ) {
        jQuery.event.special[ orig ] = {
          delegateType: fix,
          bindType: fix,

          handle: function( event ) {
            var ret,
              target = this,
              related = event.relatedTarget,
              handleObj = event.handleObj;

            // For mouseenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply( this, arguments );
              event.type = fix;
            }
            return ret;
          }
        };
      } );

      jQuery.fn.extend( {

        on: function( types, selector, data, fn ) {
          return on( this, types, selector, data, fn );
        },
        one: function( types, selector, data, fn ) {
          return on( this, types, selector, data, fn, 1 );
        },
        off: function( types, selector, fn ) {
          var handleObj, type;
          if ( types && types.preventDefault && types.handleObj ) {

            // ( event )  dispatched jQuery.Event
            handleObj = types.handleObj;
            jQuery( types.delegateTarget ).off(
              handleObj.namespace ?
                handleObj.origType + "." + handleObj.namespace :
                handleObj.origType,
              handleObj.selector,
              handleObj.handler
            );
            return this;
          }
          if ( typeof types === "object" ) {

            // ( types-object [, selector] )
            for ( type in types ) {
              this.off( type, selector, types[ type ] );
            }
            return this;
          }
          if ( selector === false || typeof selector === "function" ) {

            // ( types [, fn] )
            fn = selector;
            selector = undefined;
          }
          if ( fn === false ) {
            fn = returnFalse;
          }
          return this.each( function() {
            jQuery.event.remove( this, types, fn, selector );
          } );
        }
      } );


      var

        /* eslint-disable max-len */

        // See https://github.com/eslint/eslint/issues/3229
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

        /* eslint-enable */

        // Support: IE <=10 - 11, Edge 12 - 13 only
        // In IE/Edge using regex groups here causes severe slowdowns.
        // See https://connect.microsoft.com/IE/feedback/details/1736512/
        rnoInnerhtml = /<script|<style|<link/i,

        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

      // Prefer a tbody over its parent table for containing new rows
      function manipulationTarget( elem, content ) {
        if ( nodeName( elem, "table" ) &&
          nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

          return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
        }

        return elem;
      }

      // Replace/restore the type attribute of script elements for safe DOM manipulation
      function disableScript( elem ) {
        elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
        return elem;
      }
      function restoreScript( elem ) {
        if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
          elem.type = elem.type.slice( 5 );
        } else {
          elem.removeAttribute( "type" );
        }

        return elem;
      }

      function cloneCopyEvent( src, dest ) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if ( dest.nodeType !== 1 ) {
          return;
        }

        // 1. Copy private data: events, handlers, etc.
        if ( dataPriv.hasData( src ) ) {
          pdataOld = dataPriv.access( src );
          pdataCur = dataPriv.set( dest, pdataOld );
          events = pdataOld.events;

          if ( events ) {
            delete pdataCur.handle;
            pdataCur.events = {};

            for ( type in events ) {
              for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                jQuery.event.add( dest, type, events[ type ][ i ] );
              }
            }
          }
        }

        // 2. Copy user data
        if ( dataUser.hasData( src ) ) {
          udataOld = dataUser.access( src );
          udataCur = jQuery.extend( {}, udataOld );

          dataUser.set( dest, udataCur );
        }
      }

      // Fix IE bugs, see support tests
      function fixInput( src, dest ) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
          dest.checked = src.checked;

        // Fails to return the selected option to the default selected state when cloning options
        } else if ( nodeName === "input" || nodeName === "textarea" ) {
          dest.defaultValue = src.defaultValue;
        }
      }

      function domManip( collection, args, callback, ignored ) {

        // Flatten any nested arrays
        args = concat.apply( [], args );

        var fragment, first, scripts, hasScripts, node, doc,
          i = 0,
          l = collection.length,
          iNoClone = l - 1,
          value = args[ 0 ],
          valueIsFunction = isFunction( value );

        // We can't cloneNode fragments that contain checked, in WebKit
        if ( valueIsFunction ||
            ( l > 1 && typeof value === "string" &&
              !support.checkClone && rchecked.test( value ) ) ) {
          return collection.each( function( index ) {
            var self = collection.eq( index );
            if ( valueIsFunction ) {
              args[ 0 ] = value.call( this, index, self.html() );
            }
            domManip( self, args, callback, ignored );
          } );
        }

        if ( l ) {
          fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
          first = fragment.firstChild;

          if ( fragment.childNodes.length === 1 ) {
            fragment = first;
          }

          // Require either new content or an interest in ignored elements to invoke the callback
          if ( first || ignored ) {
            scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
            hasScripts = scripts.length;

            // Use the original fragment for the last item
            // instead of the first because it can end up
            // being emptied incorrectly in certain situations (#8070).
            for ( ; i < l; i++ ) {
              node = fragment;

              if ( i !== iNoClone ) {
                node = jQuery.clone( node, true, true );

                // Keep references to cloned scripts for later restoration
                if ( hasScripts ) {

                  // Support: Android <=4.0 only, PhantomJS 1 only
                  // push.apply(_, arraylike) throws on ancient WebKit
                  jQuery.merge( scripts, getAll( node, "script" ) );
                }
              }

              callback.call( collection[ i ], node, i );
            }

            if ( hasScripts ) {
              doc = scripts[ scripts.length - 1 ].ownerDocument;

              // Reenable scripts
              jQuery.map( scripts, restoreScript );

              // Evaluate executable scripts on first document insertion
              for ( i = 0; i < hasScripts; i++ ) {
                node = scripts[ i ];
                if ( rscriptType.test( node.type || "" ) &&
                  !dataPriv.access( node, "globalEval" ) &&
                  jQuery.contains( doc, node ) ) {

                  if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

                    // Optional AJAX dependency, but won't run scripts if not present
                    if ( jQuery._evalUrl && !node.noModule ) {
                      jQuery._evalUrl( node.src, {
                        nonce: node.nonce || node.getAttribute( "nonce" )
                      } );
                    }
                  } else {
                    DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
                  }
                }
              }
            }
          }
        }

        return collection;
      }

      function remove( elem, selector, keepData ) {
        var node,
          nodes = selector ? jQuery.filter( selector, elem ) : elem,
          i = 0;

        for ( ; ( node = nodes[ i ] ) != null; i++ ) {
          if ( !keepData && node.nodeType === 1 ) {
            jQuery.cleanData( getAll( node ) );
          }

          if ( node.parentNode ) {
            if ( keepData && isAttached( node ) ) {
              setGlobalEval( getAll( node, "script" ) );
            }
            node.parentNode.removeChild( node );
          }
        }

        return elem;
      }

      jQuery.extend( {
        htmlPrefilter: function( html ) {
          return html.replace( rxhtmlTag, "<$1></$2>" );
        },

        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
          var i, l, srcElements, destElements,
            clone = elem.cloneNode( true ),
            inPage = isAttached( elem );

          // Fix IE cloning issues
          if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
              !jQuery.isXMLDoc( elem ) ) {

            // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
            destElements = getAll( clone );
            srcElements = getAll( elem );

            for ( i = 0, l = srcElements.length; i < l; i++ ) {
              fixInput( srcElements[ i ], destElements[ i ] );
            }
          }

          // Copy the events from the original to the clone
          if ( dataAndEvents ) {
            if ( deepDataAndEvents ) {
              srcElements = srcElements || getAll( elem );
              destElements = destElements || getAll( clone );

              for ( i = 0, l = srcElements.length; i < l; i++ ) {
                cloneCopyEvent( srcElements[ i ], destElements[ i ] );
              }
            } else {
              cloneCopyEvent( elem, clone );
            }
          }

          // Preserve script evaluation history
          destElements = getAll( clone, "script" );
          if ( destElements.length > 0 ) {
            setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
          }

          // Return the cloned set
          return clone;
        },

        cleanData: function( elems ) {
          var data, elem, type,
            special = jQuery.event.special,
            i = 0;

          for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
            if ( acceptData( elem ) ) {
              if ( ( data = elem[ dataPriv.expando ] ) ) {
                if ( data.events ) {
                  for ( type in data.events ) {
                    if ( special[ type ] ) {
                      jQuery.event.remove( elem, type );

                    // This is a shortcut to avoid jQuery.event.remove's overhead
                    } else {
                      jQuery.removeEvent( elem, type, data.handle );
                    }
                  }
                }

                // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[ dataPriv.expando ] = undefined;
              }
              if ( elem[ dataUser.expando ] ) {

                // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[ dataUser.expando ] = undefined;
              }
            }
          }
        }
      } );

      jQuery.fn.extend( {
        detach: function( selector ) {
          return remove( this, selector, true );
        },

        remove: function( selector ) {
          return remove( this, selector );
        },

        text: function( value ) {
          return access( this, function( value ) {
            return value === undefined ?
              jQuery.text( this ) :
              this.empty().each( function() {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                  this.textContent = value;
                }
              } );
          }, null, value, arguments.length );
        },

        append: function() {
          return domManip( this, arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
              var target = manipulationTarget( this, elem );
              target.appendChild( elem );
            }
          } );
        },

        prepend: function() {
          return domManip( this, arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
              var target = manipulationTarget( this, elem );
              target.insertBefore( elem, target.firstChild );
            }
          } );
        },

        before: function() {
          return domManip( this, arguments, function( elem ) {
            if ( this.parentNode ) {
              this.parentNode.insertBefore( elem, this );
            }
          } );
        },

        after: function() {
          return domManip( this, arguments, function( elem ) {
            if ( this.parentNode ) {
              this.parentNode.insertBefore( elem, this.nextSibling );
            }
          } );
        },

        empty: function() {
          var elem,
            i = 0;

          for ( ; ( elem = this[ i ] ) != null; i++ ) {
            if ( elem.nodeType === 1 ) {

              // Prevent memory leaks
              jQuery.cleanData( getAll( elem, false ) );

              // Remove any remaining nodes
              elem.textContent = "";
            }
          }

          return this;
        },

        clone: function( dataAndEvents, deepDataAndEvents ) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

          return this.map( function() {
            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
          } );
        },

        html: function( value ) {
          return access( this, function( value ) {
            var elem = this[ 0 ] || {},
              i = 0,
              l = this.length;

            if ( value === undefined && elem.nodeType === 1 ) {
              return elem.innerHTML;
            }

            // See if we can take a shortcut and just use innerHTML
            if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
              !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

              value = jQuery.htmlPrefilter( value );

              try {
                for ( ; i < l; i++ ) {
                  elem = this[ i ] || {};

                  // Remove element nodes and prevent memory leaks
                  if ( elem.nodeType === 1 ) {
                    jQuery.cleanData( getAll( elem, false ) );
                    elem.innerHTML = value;
                  }
                }

                elem = 0;

              // If using innerHTML throws an exception, use the fallback method
              } catch ( e ) {}
            }

            if ( elem ) {
              this.empty().append( value );
            }
          }, null, value, arguments.length );
        },

        replaceWith: function() {
          var ignored = [];

          // Make the changes, replacing each non-ignored context element with the new content
          return domManip( this, arguments, function( elem ) {
            var parent = this.parentNode;

            if ( jQuery.inArray( this, ignored ) < 0 ) {
              jQuery.cleanData( getAll( this ) );
              if ( parent ) {
                parent.replaceChild( elem, this );
              }
            }

          // Force callback invocation
          }, ignored );
        }
      } );

      jQuery.each( {
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
          var elems,
            ret = [],
            insert = jQuery( selector ),
            last = insert.length - 1,
            i = 0;

          for ( ; i <= last; i++ ) {
            elems = i === last ? this : this.clone( true );
            jQuery( insert[ i ] )[ original ]( elems );

            // Support: Android <=4.0 only, PhantomJS 1 only
            // .get() because push.apply(_, arraylike) throws on ancient WebKit
            push.apply( ret, elems.get() );
          }

          return this.pushStack( ret );
        };
      } );
      var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

      var getStyles = function( elem ) {

          // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
          // IE throws on elements created in popups
          // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
          var view = elem.ownerDocument.defaultView;

          if ( !view || !view.opener ) {
            view = window;
          }

          return view.getComputedStyle( elem );
        };

      var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



      ( function() {

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {

          // This is a singleton, we need to execute it only once
          if ( !div ) {
            return;
          }

          container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
            "margin-top:1px;padding:0;border:0";
          div.style.cssText =
            "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
            "margin:auto;border:1px;padding:1px;" +
            "width:60%;top:1%";
          documentElement.appendChild( container ).appendChild( div );

          var divStyle = window.getComputedStyle( div );
          pixelPositionVal = divStyle.top !== "1%";

          // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
          reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

          // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
          // Some styles come back with percentage values, even though they shouldn't
          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

          // Support: IE 9 - 11 only
          // Detect misreporting of content dimensions for box-sizing:border-box elements
          boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

          // Support: IE 9 only
          // Detect overflow:scroll screwiness (gh-3699)
          // Support: Chrome <=64
          // Don't get tricked when zoom affects offsetWidth (gh-4029)
          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

          documentElement.removeChild( container );

          // Nullify the div so it wouldn't be stored in the memory and
          // it will also be a sign that checks already performed
          div = null;
        }

        function roundPixelMeasures( measure ) {
          return Math.round( parseFloat( measure ) );
        }

        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
          reliableMarginLeftVal,
          container = document.createElement( "div" ),
          div = document.createElement( "div" );

        // Finish early in limited (non-browser) environments
        if ( !div.style ) {
          return;
        }

        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode( true ).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        jQuery.extend( support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          }
        } );
      } )();


      function curCSS( elem, name, computed ) {
        var width, minWidth, maxWidth, ret,

          // Support: Firefox 51+
          // Retrieving style before computed somehow
          // fixes an issue with getting wrong values
          // on detached elements
          style = elem.style;

        computed = computed || getStyles( elem );

        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)
        if ( computed ) {
          ret = computed.getPropertyValue( name ) || computed[ name ];

          if ( ret === "" && !isAttached( elem ) ) {
            ret = jQuery.style( elem, name );
          }

          // A tribute to the "awesome hack by Dean Edwards"
          // Android Browser returns percentage for some values,
          // but width seems to be reliably pixels.
          // This is against the CSSOM draft spec:
          // https://drafts.csswg.org/cssom/#resolved-values
          if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

            // Remember the original values
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;

            // Put in the new values to get a computed value out
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;

            // Revert the changed values
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }

        return ret !== undefined ?

          // Support: IE <=9 - 11 only
          // IE returns zIndex value as an integer.
          ret + "" :
          ret;
      }


      function addGetHookIf( conditionFn, hookFn ) {

        // Define the hook, we'll check on the first run if it's really needed.
        return {
          get: function() {
            if ( conditionFn() ) {

              // Hook not needed (or it's not possible to use it due
              // to missing dependency), remove it.
              delete this.get;
              return;
            }

            // Hook needed; redefine it so that the support test is not executed again.
            return ( this.get = hookFn ).apply( this, arguments );
          }
        };
      }


      var cssPrefixes = [ "Webkit", "Moz", "ms" ],
        emptyStyle = document.createElement( "div" ).style,
        vendorProps = {};

      // Return a vendor-prefixed property or undefined
      function vendorPropName( name ) {

        // Check for vendor prefixed names
        var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
          i = cssPrefixes.length;

        while ( i-- ) {
          name = cssPrefixes[ i ] + capName;
          if ( name in emptyStyle ) {
            return name;
          }
        }
      }

      // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
      function finalPropName( name ) {
        var final = jQuery.cssProps[ name ] || vendorProps[ name ];

        if ( final ) {
          return final;
        }
        if ( name in emptyStyle ) {
          return name;
        }
        return vendorProps[ name ] = vendorPropName( name ) || name;
      }


      var

        // Swappable if display is none or starts with table
        // except "table", "table-cell", or "table-caption"
        // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rcustomProp = /^--/,
        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };

      function setPositiveNumber( elem, value, subtract ) {

        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec( value );
        return matches ?

          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
          value;
      }

      function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
        var i = dimension === "width" ? 1 : 0,
          extra = 0,
          delta = 0;

        // Adjustment may not be necessary
        if ( box === ( isBorderBox ? "border" : "content" ) ) {
          return 0;
        }

        for ( ; i < 4; i += 2 ) {

          // Both box models exclude margin
          if ( box === "margin" ) {
            delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
          }

          // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
          if ( !isBorderBox ) {

            // Add padding
            delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

            // For "border" or "margin", add border
            if ( box !== "padding" ) {
              delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

            // But still keep track of it otherwise
            } else {
              extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
            }

          // If we get here with a border-box (content + padding + border), we're seeking "content" or
          // "padding" or "margin"
          } else {

            // For "content", subtract padding
            if ( box === "content" ) {
              delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
            }

            // For "content" or "padding", subtract border
            if ( box !== "margin" ) {
              delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
            }
          }
        }

        // Account for positive content-box scroll gutter when requested by providing computedVal
        if ( !isBorderBox && computedVal >= 0 ) {

          // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
          // Assuming integer scroll gutter, subtract the rest and round down
          delta += Math.max( 0, Math.ceil(
            elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
            computedVal -
            delta -
            extra -
            0.5

          // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
          // Use an explicit zero to avoid NaN (gh-3964)
          ) ) || 0;
        }

        return delta;
      }

      function getWidthOrHeight( elem, dimension, extra ) {

        // Start with computed style
        var styles = getStyles( elem ),

          // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
          // Fake content-box until we know it's needed to know the true value.
          boxSizingNeeded = !support.boxSizingReliable() || extra,
          isBorderBox = boxSizingNeeded &&
            jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
          valueIsBorderBox = isBorderBox,

          val = curCSS( elem, dimension, styles ),
          offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

        // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.
        if ( rnumnonpx.test( val ) ) {
          if ( !extra ) {
            return val;
          }
          val = "auto";
        }


        // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        // Support: IE 9-11 only
        // Also use offsetWidth/offsetHeight for when box sizing is unreliable
        // We use getClientRects() to check for hidden/disconnected.
        // In those cases, the computed value can be trusted to be border-box
        if ( ( !support.boxSizingReliable() && isBorderBox ||
          val === "auto" ||
          !parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
          elem.getClientRects().length ) {

          isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

          // Where available, offsetWidth/offsetHeight approximate border box dimensions.
          // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
          // retrieved value as a content box dimension.
          valueIsBorderBox = offsetProp in elem;
          if ( valueIsBorderBox ) {
            val = elem[ offsetProp ];
          }
        }

        // Normalize "" and auto
        val = parseFloat( val ) || 0;

        // Adjust for the element's box model
        return ( val +
          boxModelAdjustment(
            elem,
            dimension,
            extra || ( isBorderBox ? "border" : "content" ),
            valueIsBorderBox,
            styles,

            // Provide the current computed size to request scroll gutter calculation (gh-3589)
            val
          )
        ) + "px";
      }

      jQuery.extend( {

        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function( elem, computed ) {
              if ( computed ) {

                // We should always get a number back from opacity
                var ret = curCSS( elem, "opacity" );
                return ret === "" ? "1" : ret;
              }
            }
          }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          "animationIterationCount": true,
          "columnCount": true,
          "fillOpacity": true,
          "flexGrow": true,
          "flexShrink": true,
          "fontWeight": true,
          "gridArea": true,
          "gridColumn": true,
          "gridColumnEnd": true,
          "gridColumnStart": true,
          "gridRow": true,
          "gridRowEnd": true,
          "gridRowStart": true,
          "lineHeight": true,
          "opacity": true,
          "order": true,
          "orphans": true,
          "widows": true,
          "zIndex": true,
          "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},

        // Get and set the style property on a DOM Node
        style: function( elem, name, value, extra ) {

          // Don't set styles on text and comment nodes
          if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
            return;
          }

          // Make sure that we're working with the right name
          var ret, type, hooks,
            origName = camelCase( name ),
            isCustomProp = rcustomProp.test( name ),
            style = elem.style;

          // Make sure that we're working with the right name. We don't
          // want to query the value if it is a CSS custom property
          // since they are user-defined.
          if ( !isCustomProp ) {
            name = finalPropName( origName );
          }

          // Gets hook for the prefixed version, then unprefixed version
          hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

          // Check if we're setting a value
          if ( value !== undefined ) {
            type = typeof value;

            // Convert "+=" or "-=" to relative numbers (#7345)
            if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
              value = adjustCSS( elem, name, ret );

              // Fixes bug #9237
              type = "number";
            }

            // Make sure that null and NaN values aren't set (#7116)
            if ( value == null || value !== value ) {
              return;
            }

            // If a number was passed in, add the unit (except for certain CSS properties)
            // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
            // "px" to a few hardcoded values.
            if ( type === "number" && !isCustomProp ) {
              value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
            }

            // background-* props affect original clone's values
            if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
              style[ name ] = "inherit";
            }

            // If a hook was provided, use that value, otherwise just set the specified value
            if ( !hooks || !( "set" in hooks ) ||
              ( value = hooks.set( elem, value, extra ) ) !== undefined ) {

              if ( isCustomProp ) {
                style.setProperty( name, value );
              } else {
                style[ name ] = value;
              }
            }

          } else {

            // If a hook was provided get the non-computed value from there
            if ( hooks && "get" in hooks &&
              ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

              return ret;
            }

            // Otherwise just get the value from the style object
            return style[ name ];
          }
        },

        css: function( elem, name, extra, styles ) {
          var val, num, hooks,
            origName = camelCase( name ),
            isCustomProp = rcustomProp.test( name );

          // Make sure that we're working with the right name. We don't
          // want to modify the value if it is a CSS custom property
          // since they are user-defined.
          if ( !isCustomProp ) {
            name = finalPropName( origName );
          }

          // Try prefixed name followed by the unprefixed name
          hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

          // If a hook was provided get the computed value from there
          if ( hooks && "get" in hooks ) {
            val = hooks.get( elem, true, extra );
          }

          // Otherwise, if a way to get the computed value exists, use that
          if ( val === undefined ) {
            val = curCSS( elem, name, styles );
          }

          // Convert "normal" to computed value
          if ( val === "normal" && name in cssNormalTransform ) {
            val = cssNormalTransform[ name ];
          }

          // Make numeric if forced or a qualifier was provided and val looks numeric
          if ( extra === "" || extra ) {
            num = parseFloat( val );
            return extra === true || isFinite( num ) ? num || 0 : val;
          }

          return val;
        }
      } );

      jQuery.each( [ "height", "width" ], function( i, dimension ) {
        jQuery.cssHooks[ dimension ] = {
          get: function( elem, computed, extra ) {
            if ( computed ) {

              // Certain elements can have dimension info if we invisibly show them
              // but it must have a current display style that would benefit
              return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

                // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                ( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
                  swap( elem, cssShow, function() {
                    return getWidthOrHeight( elem, dimension, extra );
                  } ) :
                  getWidthOrHeight( elem, dimension, extra );
            }
          },

          set: function( elem, value, extra ) {
            var matches,
              styles = getStyles( elem ),

              // Only read styles.position if the test has a chance to fail
              // to avoid forcing a reflow.
              scrollboxSizeBuggy = !support.scrollboxSize() &&
                styles.position === "absolute",

              // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
              boxSizingNeeded = scrollboxSizeBuggy || extra,
              isBorderBox = boxSizingNeeded &&
                jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
              subtract = extra ?
                boxModelAdjustment(
                  elem,
                  dimension,
                  extra,
                  isBorderBox,
                  styles
                ) :
                0;

            // Account for unreliable border-box dimensions by comparing offset* to computed and
            // faking a content-box to get border and padding (gh-3699)
            if ( isBorderBox && scrollboxSizeBuggy ) {
              subtract -= Math.ceil(
                elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
                parseFloat( styles[ dimension ] ) -
                boxModelAdjustment( elem, dimension, "border", false, styles ) -
                0.5
              );
            }

            // Convert to pixels if value adjustment is needed
            if ( subtract && ( matches = rcssNum.exec( value ) ) &&
              ( matches[ 3 ] || "px" ) !== "px" ) {

              elem.style[ dimension ] = value;
              value = jQuery.css( elem, dimension );
            }

            return setPositiveNumber( elem, value, subtract );
          }
        };
      } );

      jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
        function( elem, computed ) {
          if ( computed ) {
            return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
              elem.getBoundingClientRect().left -
                swap( elem, { marginLeft: 0 }, function() {
                  return elem.getBoundingClientRect().left;
                } )
              ) + "px";
          }
        }
      );

      // These hooks are used by animate to expand properties
      jQuery.each( {
        margin: "",
        padding: "",
        border: "Width"
      }, function( prefix, suffix ) {
        jQuery.cssHooks[ prefix + suffix ] = {
          expand: function( value ) {
            var i = 0,
              expanded = {},

              // Assumes a single number if not a string
              parts = typeof value === "string" ? value.split( " " ) : [ value ];

            for ( ; i < 4; i++ ) {
              expanded[ prefix + cssExpand[ i ] + suffix ] =
                parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
            }

            return expanded;
          }
        };

        if ( prefix !== "margin" ) {
          jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
        }
      } );

      jQuery.fn.extend( {
        css: function( name, value ) {
          return access( this, function( elem, name, value ) {
            var styles, len,
              map = {},
              i = 0;

            if ( Array.isArray( name ) ) {
              styles = getStyles( elem );
              len = name.length;

              for ( ; i < len; i++ ) {
                map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
              }

              return map;
            }

            return value !== undefined ?
              jQuery.style( elem, name, value ) :
              jQuery.css( elem, name );
          }, name, value, arguments.length > 1 );
        }
      } );


      function Tween( elem, options, prop, end, easing ) {
        return new Tween.prototype.init( elem, options, prop, end, easing );
      }
      jQuery.Tween = Tween;

      Tween.prototype = {
        constructor: Tween,
        init: function( elem, options, prop, end, easing, unit ) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
        },
        cur: function() {
          var hooks = Tween.propHooks[ this.prop ];

          return hooks && hooks.get ?
            hooks.get( this ) :
            Tween.propHooks._default.get( this );
        },
        run: function( percent ) {
          var eased,
            hooks = Tween.propHooks[ this.prop ];

          if ( this.options.duration ) {
            this.pos = eased = jQuery.easing[ this.easing ](
              percent, this.options.duration * percent, 0, 1, this.options.duration
            );
          } else {
            this.pos = eased = percent;
          }
          this.now = ( this.end - this.start ) * eased + this.start;

          if ( this.options.step ) {
            this.options.step.call( this.elem, this.now, this );
          }

          if ( hooks && hooks.set ) {
            hooks.set( this );
          } else {
            Tween.propHooks._default.set( this );
          }
          return this;
        }
      };

      Tween.prototype.init.prototype = Tween.prototype;

      Tween.propHooks = {
        _default: {
          get: function( tween ) {
            var result;

            // Use a property on the element directly when it is not a DOM element,
            // or when there is no matching style property that exists.
            if ( tween.elem.nodeType !== 1 ||
              tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
              return tween.elem[ tween.prop ];
            }

            // Passing an empty string as a 3rd parameter to .css will automatically
            // attempt a parseFloat and fallback to a string if the parse fails.
            // Simple values such as "10px" are parsed to Float;
            // complex values such as "rotate(1rad)" are returned as-is.
            result = jQuery.css( tween.elem, tween.prop, "" );

            // Empty strings, null, undefined and "auto" are converted to 0.
            return !result || result === "auto" ? 0 : result;
          },
          set: function( tween ) {

            // Use step hook for back compat.
            // Use cssHook if its there.
            // Use .style if available and use plain properties where available.
            if ( jQuery.fx.step[ tween.prop ] ) {
              jQuery.fx.step[ tween.prop ]( tween );
            } else if ( tween.elem.nodeType === 1 && (
                jQuery.cssHooks[ tween.prop ] ||
                tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
              jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
            } else {
              tween.elem[ tween.prop ] = tween.now;
            }
          }
        }
      };

      // Support: IE <=9 only
      // Panic based approach to setting things on disconnected nodes
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function( tween ) {
          if ( tween.elem.nodeType && tween.elem.parentNode ) {
            tween.elem[ tween.prop ] = tween.now;
          }
        }
      };

      jQuery.easing = {
        linear: function( p ) {
          return p;
        },
        swing: function( p ) {
          return 0.5 - Math.cos( p * Math.PI ) / 2;
        },
        _default: "swing"
      };

      jQuery.fx = Tween.prototype.init;

      // Back compat <1.8 extension point
      jQuery.fx.step = {};




      var
        fxNow, inProgress,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

      function schedule() {
        if ( inProgress ) {
          if ( document.hidden === false && window.requestAnimationFrame ) {
            window.requestAnimationFrame( schedule );
          } else {
            window.setTimeout( schedule, jQuery.fx.interval );
          }

          jQuery.fx.tick();
        }
      }

      // Animations created synchronously will run synchronously
      function createFxNow() {
        window.setTimeout( function() {
          fxNow = undefined;
        } );
        return ( fxNow = Date.now() );
      }

      // Generate parameters to create a standard animation
      function genFx( type, includeWidth ) {
        var which,
          i = 0,
          attrs = { height: type };

        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for ( ; i < 4; i += 2 - includeWidth ) {
          which = cssExpand[ i ];
          attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
        }

        if ( includeWidth ) {
          attrs.opacity = attrs.width = type;
        }

        return attrs;
      }

      function createTween( value, prop, animation ) {
        var tween,
          collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
          index = 0,
          length = collection.length;
        for ( ; index < length; index++ ) {
          if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

            // We're done with this property
            return tween;
          }
        }
      }

      function defaultPrefilter( elem, props, opts ) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
          isBox = "width" in props || "height" in props,
          anim = this,
          orig = {},
          style = elem.style,
          hidden = elem.nodeType && isHiddenWithinTree( elem ),
          dataShow = dataPriv.get( elem, "fxshow" );

        // Queue-skipping animations hijack the fx hooks
        if ( !opts.queue ) {
          hooks = jQuery._queueHooks( elem, "fx" );
          if ( hooks.unqueued == null ) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if ( !hooks.unqueued ) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;

          anim.always( function() {

            // Ensure the complete handler is called before this completes
            anim.always( function() {
              hooks.unqueued--;
              if ( !jQuery.queue( elem, "fx" ).length ) {
                hooks.empty.fire();
              }
            } );
          } );
        }

        // Detect show/hide animations
        for ( prop in props ) {
          value = props[ prop ];
          if ( rfxtypes.test( value ) ) {
            delete props[ prop ];
            toggle = toggle || value === "toggle";
            if ( value === ( hidden ? "hide" : "show" ) ) {

              // Pretend to be hidden if this is a "show" and
              // there is still data from a stopped show/hide
              if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                hidden = true;

              // Ignore all other no-op show/hide data
              } else {
                continue;
              }
            }
            orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
          }
        }

        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject( props );
        if ( !propTween && jQuery.isEmptyObject( orig ) ) {
          return;
        }

        // Restrict "overflow" and "display" styles during box animations
        if ( isBox && elem.nodeType === 1 ) {

          // Support: IE <=9 - 11, Edge 12 - 15
          // Record all 3 overflow attributes because IE does not infer the shorthand
          // from identically-valued overflowX and overflowY and Edge just mirrors
          // the overflowX value there.
          opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

          // Identify a display type, preferring old show/hide data over the CSS cascade
          restoreDisplay = dataShow && dataShow.display;
          if ( restoreDisplay == null ) {
            restoreDisplay = dataPriv.get( elem, "display" );
          }
          display = jQuery.css( elem, "display" );
          if ( display === "none" ) {
            if ( restoreDisplay ) {
              display = restoreDisplay;
            } else {

              // Get nonempty value(s) by temporarily forcing visibility
              showHide( [ elem ], true );
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery.css( elem, "display" );
              showHide( [ elem ] );
            }
          }

          // Animate inline elements as inline-block
          if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
            if ( jQuery.css( elem, "float" ) === "none" ) {

              // Restore the original display value at the end of pure show/hide animations
              if ( !propTween ) {
                anim.done( function() {
                  style.display = restoreDisplay;
                } );
                if ( restoreDisplay == null ) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }
              style.display = "inline-block";
            }
          }
        }

        if ( opts.overflow ) {
          style.overflow = "hidden";
          anim.always( function() {
            style.overflow = opts.overflow[ 0 ];
            style.overflowX = opts.overflow[ 1 ];
            style.overflowY = opts.overflow[ 2 ];
          } );
        }

        // Implement show/hide animations
        propTween = false;
        for ( prop in orig ) {

          // General show/hide setup for this element animation
          if ( !propTween ) {
            if ( dataShow ) {
              if ( "hidden" in dataShow ) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
            }

            // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
            if ( toggle ) {
              dataShow.hidden = !hidden;
            }

            // Show elements before animating them
            if ( hidden ) {
              showHide( [ elem ], true );
            }

            /* eslint-disable no-loop-func */

            anim.done( function() {

            /* eslint-enable no-loop-func */

              // The final step of a "hide" animation is actually hiding the element
              if ( !hidden ) {
                showHide( [ elem ] );
              }
              dataPriv.remove( elem, "fxshow" );
              for ( prop in orig ) {
                jQuery.style( elem, prop, orig[ prop ] );
              }
            } );
          }

          // Per-property setup
          propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
          if ( !( prop in dataShow ) ) {
            dataShow[ prop ] = propTween.start;
            if ( hidden ) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }

      function propFilter( props, specialEasing ) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for ( index in props ) {
          name = camelCase( index );
          easing = specialEasing[ name ];
          value = props[ index ];
          if ( Array.isArray( value ) ) {
            easing = value[ 1 ];
            value = props[ index ] = value[ 0 ];
          }

          if ( index !== name ) {
            props[ name ] = value;
            delete props[ index ];
          }

          hooks = jQuery.cssHooks[ name ];
          if ( hooks && "expand" in hooks ) {
            value = hooks.expand( value );
            delete props[ name ];

            // Not quite $.extend, this won't overwrite existing keys.
            // Reusing 'index' because we have the correct "name"
            for ( index in value ) {
              if ( !( index in props ) ) {
                props[ index ] = value[ index ];
                specialEasing[ index ] = easing;
              }
            }
          } else {
            specialEasing[ name ] = easing;
          }
        }
      }

      function Animation( elem, properties, options ) {
        var result,
          stopped,
          index = 0,
          length = Animation.prefilters.length,
          deferred = jQuery.Deferred().always( function() {

            // Don't match elem in the :animated selector
            delete tick.elem;
          } ),
          tick = function() {
            if ( stopped ) {
              return false;
            }
            var currentTime = fxNow || createFxNow(),
              remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

              // Support: Android 2.3 only
              // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;

            for ( ; index < length; index++ ) {
              animation.tweens[ index ].run( percent );
            }

            deferred.notifyWith( elem, [ animation, percent, remaining ] );

            // If there's more to do, yield
            if ( percent < 1 && length ) {
              return remaining;
            }

            // If this was an empty animation, synthesize a final progress notification
            if ( !length ) {
              deferred.notifyWith( elem, [ animation, 1, 0 ] );
            }

            // Resolve the animation and report its conclusion
            deferred.resolveWith( elem, [ animation ] );
            return false;
          },
          animation = deferred.promise( {
            elem: elem,
            props: jQuery.extend( {}, properties ),
            opts: jQuery.extend( true, {
              specialEasing: {},
              easing: jQuery.easing._default
            }, options ),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function( prop, end ) {
              var tween = jQuery.Tween( elem, animation.opts, prop, end,
                  animation.opts.specialEasing[ prop ] || animation.opts.easing );
              animation.tweens.push( tween );
              return tween;
            },
            stop: function( gotoEnd ) {
              var index = 0,

                // If we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
              if ( stopped ) {
                return this;
              }
              stopped = true;
              for ( ; index < length; index++ ) {
                animation.tweens[ index ].run( 1 );
              }

              // Resolve when we played the last frame; otherwise, reject
              if ( gotoEnd ) {
                deferred.notifyWith( elem, [ animation, 1, 0 ] );
                deferred.resolveWith( elem, [ animation, gotoEnd ] );
              } else {
                deferred.rejectWith( elem, [ animation, gotoEnd ] );
              }
              return this;
            }
          } ),
          props = animation.props;

        propFilter( props, animation.opts.specialEasing );

        for ( ; index < length; index++ ) {
          result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
          if ( result ) {
            if ( isFunction( result.stop ) ) {
              jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
                result.stop.bind( result );
            }
            return result;
          }
        }

        jQuery.map( props, createTween, animation );

        if ( isFunction( animation.opts.start ) ) {
          animation.opts.start.call( elem, animation );
        }

        // Attach callbacks from options
        animation
          .progress( animation.opts.progress )
          .done( animation.opts.done, animation.opts.complete )
          .fail( animation.opts.fail )
          .always( animation.opts.always );

        jQuery.fx.timer(
          jQuery.extend( tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
          } )
        );

        return animation;
      }

      jQuery.Animation = jQuery.extend( Animation, {

        tweeners: {
          "*": [ function( prop, value ) {
            var tween = this.createTween( prop, value );
            adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
            return tween;
          } ]
        },

        tweener: function( props, callback ) {
          if ( isFunction( props ) ) {
            callback = props;
            props = [ "*" ];
          } else {
            props = props.match( rnothtmlwhite );
          }

          var prop,
            index = 0,
            length = props.length;

          for ( ; index < length; index++ ) {
            prop = props[ index ];
            Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
            Animation.tweeners[ prop ].unshift( callback );
          }
        },

        prefilters: [ defaultPrefilter ],

        prefilter: function( callback, prepend ) {
          if ( prepend ) {
            Animation.prefilters.unshift( callback );
          } else {
            Animation.prefilters.push( callback );
          }
        }
      } );

      jQuery.speed = function( speed, easing, fn ) {
        var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
          complete: fn || !fn && easing ||
            isFunction( speed ) && speed,
          duration: speed,
          easing: fn && easing || easing && !isFunction( easing ) && easing
        };

        // Go to the end state if fx are off
        if ( jQuery.fx.off ) {
          opt.duration = 0;

        } else {
          if ( typeof opt.duration !== "number" ) {
            if ( opt.duration in jQuery.fx.speeds ) {
              opt.duration = jQuery.fx.speeds[ opt.duration ];

            } else {
              opt.duration = jQuery.fx.speeds._default;
            }
          }
        }

        // Normalize opt.queue - true/undefined/null -> "fx"
        if ( opt.queue == null || opt.queue === true ) {
          opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function() {
          if ( isFunction( opt.old ) ) {
            opt.old.call( this );
          }

          if ( opt.queue ) {
            jQuery.dequeue( this, opt.queue );
          }
        };

        return opt;
      };

      jQuery.fn.extend( {
        fadeTo: function( speed, to, easing, callback ) {

          // Show any hidden elements after setting opacity to 0
          return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

            // Animate to the value specified
            .end().animate( { opacity: to }, speed, easing, callback );
        },
        animate: function( prop, speed, easing, callback ) {
          var empty = jQuery.isEmptyObject( prop ),
            optall = jQuery.speed( speed, easing, callback ),
            doAnimation = function() {

              // Operate on a copy of prop so per-property easing won't be lost
              var anim = Animation( this, jQuery.extend( {}, prop ), optall );

              // Empty animations, or finishing resolves immediately
              if ( empty || dataPriv.get( this, "finish" ) ) {
                anim.stop( true );
              }
            };
            doAnimation.finish = doAnimation;

          return empty || optall.queue === false ?
            this.each( doAnimation ) :
            this.queue( optall.queue, doAnimation );
        },
        stop: function( type, clearQueue, gotoEnd ) {
          var stopQueue = function( hooks ) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop( gotoEnd );
          };

          if ( typeof type !== "string" ) {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
          }
          if ( clearQueue && type !== false ) {
            this.queue( type || "fx", [] );
          }

          return this.each( function() {
            var dequeue = true,
              index = type != null && type + "queueHooks",
              timers = jQuery.timers,
              data = dataPriv.get( this );

            if ( index ) {
              if ( data[ index ] && data[ index ].stop ) {
                stopQueue( data[ index ] );
              }
            } else {
              for ( index in data ) {
                if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                  stopQueue( data[ index ] );
                }
              }
            }

            for ( index = timers.length; index--; ) {
              if ( timers[ index ].elem === this &&
                ( type == null || timers[ index ].queue === type ) ) {

                timers[ index ].anim.stop( gotoEnd );
                dequeue = false;
                timers.splice( index, 1 );
              }
            }

            // Start the next in the queue if the last step wasn't forced.
            // Timers currently will call their complete callbacks, which
            // will dequeue but only if they were gotoEnd.
            if ( dequeue || !gotoEnd ) {
              jQuery.dequeue( this, type );
            }
          } );
        },
        finish: function( type ) {
          if ( type !== false ) {
            type = type || "fx";
          }
          return this.each( function() {
            var index,
              data = dataPriv.get( this ),
              queue = data[ type + "queue" ],
              hooks = data[ type + "queueHooks" ],
              timers = jQuery.timers,
              length = queue ? queue.length : 0;

            // Enable finishing flag on private data
            data.finish = true;

            // Empty the queue first
            jQuery.queue( this, type, [] );

            if ( hooks && hooks.stop ) {
              hooks.stop.call( this, true );
            }

            // Look for any active animations, and finish them
            for ( index = timers.length; index--; ) {
              if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                timers[ index ].anim.stop( true );
                timers.splice( index, 1 );
              }
            }

            // Look for any animations in the old queue and finish them
            for ( index = 0; index < length; index++ ) {
              if ( queue[ index ] && queue[ index ].finish ) {
                queue[ index ].finish.call( this );
              }
            }

            // Turn off finishing flag
            delete data.finish;
          } );
        }
      } );

      jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
        var cssFn = jQuery.fn[ name ];
        jQuery.fn[ name ] = function( speed, easing, callback ) {
          return speed == null || typeof speed === "boolean" ?
            cssFn.apply( this, arguments ) :
            this.animate( genFx( name, true ), speed, easing, callback );
        };
      } );

      // Generate shortcuts for custom animations
      jQuery.each( {
        slideDown: genFx( "show" ),
        slideUp: genFx( "hide" ),
        slideToggle: genFx( "toggle" ),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function( name, props ) {
        jQuery.fn[ name ] = function( speed, easing, callback ) {
          return this.animate( props, speed, easing, callback );
        };
      } );

      jQuery.timers = [];
      jQuery.fx.tick = function() {
        var timer,
          i = 0,
          timers = jQuery.timers;

        fxNow = Date.now();

        for ( ; i < timers.length; i++ ) {
          timer = timers[ i ];

          // Run the timer and safely remove it when done (allowing for external removal)
          if ( !timer() && timers[ i ] === timer ) {
            timers.splice( i--, 1 );
          }
        }

        if ( !timers.length ) {
          jQuery.fx.stop();
        }
        fxNow = undefined;
      };

      jQuery.fx.timer = function( timer ) {
        jQuery.timers.push( timer );
        jQuery.fx.start();
      };

      jQuery.fx.interval = 13;
      jQuery.fx.start = function() {
        if ( inProgress ) {
          return;
        }

        inProgress = true;
        schedule();
      };

      jQuery.fx.stop = function() {
        inProgress = null;
      };

      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,

        // Default speed
        _default: 400
      };


      // Based off of the plugin by Clint Helfers, with permission.
      // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
      jQuery.fn.delay = function( time, type ) {
        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
        type = type || "fx";

        return this.queue( type, function( next, hooks ) {
          var timeout = window.setTimeout( next, time );
          hooks.stop = function() {
            window.clearTimeout( timeout );
          };
        } );
      };


      ( function() {
        var input = document.createElement( "input" ),
          select = document.createElement( "select" ),
          opt = select.appendChild( document.createElement( "option" ) );

        input.type = "checkbox";

        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";

        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;

        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document.createElement( "input" );
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      } )();


      var boolHook,
        attrHandle = jQuery.expr.attrHandle;

      jQuery.fn.extend( {
        attr: function( name, value ) {
          return access( this, jQuery.attr, name, value, arguments.length > 1 );
        },

        removeAttr: function( name ) {
          return this.each( function() {
            jQuery.removeAttr( this, name );
          } );
        }
      } );

      jQuery.extend( {
        attr: function( elem, name, value ) {
          var ret, hooks,
            nType = elem.nodeType;

          // Don't get/set attributes on text, comment and attribute nodes
          if ( nType === 3 || nType === 8 || nType === 2 ) {
            return;
          }

          // Fallback to prop when attributes are not supported
          if ( typeof elem.getAttribute === "undefined" ) {
            return jQuery.prop( elem, name, value );
          }

          // Attribute hooks are determined by the lowercase version
          // Grab necessary hook if one is defined
          if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
            hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
              ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
          }

          if ( value !== undefined ) {
            if ( value === null ) {
              jQuery.removeAttr( elem, name );
              return;
            }

            if ( hooks && "set" in hooks &&
              ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
              return ret;
            }

            elem.setAttribute( name, value + "" );
            return value;
          }

          if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
            return ret;
          }

          ret = jQuery.find.attr( elem, name );

          // Non-existent attributes return null, we normalize to undefined
          return ret == null ? undefined : ret;
        },

        attrHooks: {
          type: {
            set: function( elem, value ) {
              if ( !support.radioValue && value === "radio" &&
                nodeName( elem, "input" ) ) {
                var val = elem.value;
                elem.setAttribute( "type", value );
                if ( val ) {
                  elem.value = val;
                }
                return value;
              }
            }
          }
        },

        removeAttr: function( elem, value ) {
          var name,
            i = 0,

            // Attribute names can contain non-HTML whitespace characters
            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
            attrNames = value && value.match( rnothtmlwhite );

          if ( attrNames && elem.nodeType === 1 ) {
            while ( ( name = attrNames[ i++ ] ) ) {
              elem.removeAttribute( name );
            }
          }
        }
      } );

      // Hooks for boolean attributes
      boolHook = {
        set: function( elem, value, name ) {
          if ( value === false ) {

            // Remove boolean attributes when set to false
            jQuery.removeAttr( elem, name );
          } else {
            elem.setAttribute( name, name );
          }
          return name;
        }
      };

      jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
        var getter = attrHandle[ name ] || jQuery.find.attr;

        attrHandle[ name ] = function( elem, name, isXML ) {
          var ret, handle,
            lowercaseName = name.toLowerCase();

          if ( !isXML ) {

            // Avoid an infinite loop by temporarily removing this function from the getter
            handle = attrHandle[ lowercaseName ];
            attrHandle[ lowercaseName ] = ret;
            ret = getter( elem, name, isXML ) != null ?
              lowercaseName :
              null;
            attrHandle[ lowercaseName ] = handle;
          }
          return ret;
        };
      } );




      var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;

      jQuery.fn.extend( {
        prop: function( name, value ) {
          return access( this, jQuery.prop, name, value, arguments.length > 1 );
        },

        removeProp: function( name ) {
          return this.each( function() {
            delete this[ jQuery.propFix[ name ] || name ];
          } );
        }
      } );

      jQuery.extend( {
        prop: function( elem, name, value ) {
          var ret, hooks,
            nType = elem.nodeType;

          // Don't get/set properties on text, comment and attribute nodes
          if ( nType === 3 || nType === 8 || nType === 2 ) {
            return;
          }

          if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

            // Fix name and attach hooks
            name = jQuery.propFix[ name ] || name;
            hooks = jQuery.propHooks[ name ];
          }

          if ( value !== undefined ) {
            if ( hooks && "set" in hooks &&
              ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
              return ret;
            }

            return ( elem[ name ] = value );
          }

          if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
            return ret;
          }

          return elem[ name ];
        },

        propHooks: {
          tabIndex: {
            get: function( elem ) {

              // Support: IE <=9 - 11 only
              // elem.tabIndex doesn't always return the
              // correct value when it hasn't been explicitly set
              // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
              // Use proper attribute retrieval(#12072)
              var tabindex = jQuery.find.attr( elem, "tabindex" );

              if ( tabindex ) {
                return parseInt( tabindex, 10 );
              }

              if (
                rfocusable.test( elem.nodeName ) ||
                rclickable.test( elem.nodeName ) &&
                elem.href
              ) {
                return 0;
              }

              return -1;
            }
          }
        },

        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      } );

      // Support: IE <=11 only
      // Accessing the selectedIndex property
      // forces the browser to respect setting selected
      // on the option
      // The getter ensures a default option is selected
      // when in an optgroup
      // eslint rule "no-unused-expressions" is disabled for this code
      // since it considers such accessions noop
      if ( !support.optSelected ) {
        jQuery.propHooks.selected = {
          get: function( elem ) {

            /* eslint no-unused-expressions: "off" */

            var parent = elem.parentNode;
            if ( parent && parent.parentNode ) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function( elem ) {

            /* eslint no-unused-expressions: "off" */

            var parent = elem.parentNode;
            if ( parent ) {
              parent.selectedIndex;

              if ( parent.parentNode ) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }

      jQuery.each( [
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
      ], function() {
        jQuery.propFix[ this.toLowerCase() ] = this;
      } );




        // Strip and collapse whitespace according to HTML spec
        // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
        function stripAndCollapse( value ) {
          var tokens = value.match( rnothtmlwhite ) || [];
          return tokens.join( " " );
        }


      function getClass( elem ) {
        return elem.getAttribute && elem.getAttribute( "class" ) || "";
      }

      function classesToArray( value ) {
        if ( Array.isArray( value ) ) {
          return value;
        }
        if ( typeof value === "string" ) {
          return value.match( rnothtmlwhite ) || [];
        }
        return [];
      }

      jQuery.fn.extend( {
        addClass: function( value ) {
          var classes, elem, cur, curValue, clazz, j, finalValue,
            i = 0;

          if ( isFunction( value ) ) {
            return this.each( function( j ) {
              jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
            } );
          }

          classes = classesToArray( value );

          if ( classes.length ) {
            while ( ( elem = this[ i++ ] ) ) {
              curValue = getClass( elem );
              cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

              if ( cur ) {
                j = 0;
                while ( ( clazz = classes[ j++ ] ) ) {
                  if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                    cur += clazz + " ";
                  }
                }

                // Only assign if different to avoid unneeded rendering.
                finalValue = stripAndCollapse( cur );
                if ( curValue !== finalValue ) {
                  elem.setAttribute( "class", finalValue );
                }
              }
            }
          }

          return this;
        },

        removeClass: function( value ) {
          var classes, elem, cur, curValue, clazz, j, finalValue,
            i = 0;

          if ( isFunction( value ) ) {
            return this.each( function( j ) {
              jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
            } );
          }

          if ( !arguments.length ) {
            return this.attr( "class", "" );
          }

          classes = classesToArray( value );

          if ( classes.length ) {
            while ( ( elem = this[ i++ ] ) ) {
              curValue = getClass( elem );

              // This expression is here for better compressibility (see addClass)
              cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

              if ( cur ) {
                j = 0;
                while ( ( clazz = classes[ j++ ] ) ) {

                  // Remove *all* instances
                  while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                    cur = cur.replace( " " + clazz + " ", " " );
                  }
                }

                // Only assign if different to avoid unneeded rendering.
                finalValue = stripAndCollapse( cur );
                if ( curValue !== finalValue ) {
                  elem.setAttribute( "class", finalValue );
                }
              }
            }
          }

          return this;
        },

        toggleClass: function( value, stateVal ) {
          var type = typeof value,
            isValidValue = type === "string" || Array.isArray( value );

          if ( typeof stateVal === "boolean" && isValidValue ) {
            return stateVal ? this.addClass( value ) : this.removeClass( value );
          }

          if ( isFunction( value ) ) {
            return this.each( function( i ) {
              jQuery( this ).toggleClass(
                value.call( this, i, getClass( this ), stateVal ),
                stateVal
              );
            } );
          }

          return this.each( function() {
            var className, i, self, classNames;

            if ( isValidValue ) {

              // Toggle individual class names
              i = 0;
              self = jQuery( this );
              classNames = classesToArray( value );

              while ( ( className = classNames[ i++ ] ) ) {

                // Check each className given, space separated list
                if ( self.hasClass( className ) ) {
                  self.removeClass( className );
                } else {
                  self.addClass( className );
                }
              }

            // Toggle whole class name
            } else if ( value === undefined || type === "boolean" ) {
              className = getClass( this );
              if ( className ) {

                // Store className if set
                dataPriv.set( this, "__className__", className );
              }

              // If the element has a class name or if we're passed `false`,
              // then remove the whole classname (if there was one, the above saved it).
              // Otherwise bring back whatever was previously saved (if anything),
              // falling back to the empty string if nothing was stored.
              if ( this.setAttribute ) {
                this.setAttribute( "class",
                  className || value === false ?
                  "" :
                  dataPriv.get( this, "__className__" ) || ""
                );
              }
            }
          } );
        },

        hasClass: function( selector ) {
          var className, elem,
            i = 0;

          className = " " + selector + " ";
          while ( ( elem = this[ i++ ] ) ) {
            if ( elem.nodeType === 1 &&
              ( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
                return true;
            }
          }

          return false;
        }
      } );




      var rreturn = /\r/g;

      jQuery.fn.extend( {
        val: function( value ) {
          var hooks, ret, valueIsFunction,
            elem = this[ 0 ];

          if ( !arguments.length ) {
            if ( elem ) {
              hooks = jQuery.valHooks[ elem.type ] ||
                jQuery.valHooks[ elem.nodeName.toLowerCase() ];

              if ( hooks &&
                "get" in hooks &&
                ( ret = hooks.get( elem, "value" ) ) !== undefined
              ) {
                return ret;
              }

              ret = elem.value;

              // Handle most common string cases
              if ( typeof ret === "string" ) {
                return ret.replace( rreturn, "" );
              }

              // Handle cases where value is null/undef or number
              return ret == null ? "" : ret;
            }

            return;
          }

          valueIsFunction = isFunction( value );

          return this.each( function( i ) {
            var val;

            if ( this.nodeType !== 1 ) {
              return;
            }

            if ( valueIsFunction ) {
              val = value.call( this, i, jQuery( this ).val() );
            } else {
              val = value;
            }

            // Treat null/undefined as ""; convert numbers to string
            if ( val == null ) {
              val = "";

            } else if ( typeof val === "number" ) {
              val += "";

            } else if ( Array.isArray( val ) ) {
              val = jQuery.map( val, function( value ) {
                return value == null ? "" : value + "";
              } );
            }

            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

            // If set returns undefined, fall back to normal setting
            if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
              this.value = val;
            }
          } );
        }
      } );

      jQuery.extend( {
        valHooks: {
          option: {
            get: function( elem ) {

              var val = jQuery.find.attr( elem, "value" );
              return val != null ?
                val :

                // Support: IE <=10 - 11 only
                // option.text throws exceptions (#14686, #14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse( jQuery.text( elem ) );
            }
          },
          select: {
            get: function( elem ) {
              var value, option, i,
                options = elem.options,
                index = elem.selectedIndex,
                one = elem.type === "select-one",
                values = one ? null : [],
                max = one ? index + 1 : options.length;

              if ( index < 0 ) {
                i = max;

              } else {
                i = one ? index : 0;
              }

              // Loop through all the selected options
              for ( ; i < max; i++ ) {
                option = options[ i ];

                // Support: IE <=9 only
                // IE8-9 doesn't update selected after form reset (#2551)
                if ( ( option.selected || i === index ) &&

                    // Don't return options that are disabled or in a disabled optgroup
                    !option.disabled &&
                    ( !option.parentNode.disabled ||
                      !nodeName( option.parentNode, "optgroup" ) ) ) {

                  // Get the specific value for the option
                  value = jQuery( option ).val();

                  // We don't need an array for one selects
                  if ( one ) {
                    return value;
                  }

                  // Multi-Selects return an array
                  values.push( value );
                }
              }

              return values;
            },

            set: function( elem, value ) {
              var optionSet, option,
                options = elem.options,
                values = jQuery.makeArray( value ),
                i = options.length;

              while ( i-- ) {
                option = options[ i ];

                /* eslint-disable no-cond-assign */

                if ( option.selected =
                  jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
                ) {
                  optionSet = true;
                }

                /* eslint-enable no-cond-assign */
              }

              // Force browsers to behave consistently when non-matching value is set
              if ( !optionSet ) {
                elem.selectedIndex = -1;
              }
              return values;
            }
          }
        }
      } );

      // Radios and checkboxes getter/setter
      jQuery.each( [ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = {
          set: function( elem, value ) {
            if ( Array.isArray( value ) ) {
              return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
            }
          }
        };
        if ( !support.checkOn ) {
          jQuery.valHooks[ this ].get = function( elem ) {
            return elem.getAttribute( "value" ) === null ? "on" : elem.value;
          };
        }
      } );




      // Return jQuery for attributes-only inclusion


      support.focusin = "onfocusin" in window;


      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        stopPropagationCallback = function( e ) {
          e.stopPropagation();
        };

      jQuery.extend( jQuery.event, {

        trigger: function( event, data, elem, onlyHandlers ) {

          var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
            eventPath = [ elem || document ],
            type = hasOwn.call( event, "type" ) ? event.type : event,
            namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

          cur = lastElement = tmp = elem = elem || document;

          // Don't do events on text and comment nodes
          if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
            return;
          }

          // focus/blur morphs to focusin/out; ensure we're not firing them right now
          if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
            return;
          }

          if ( type.indexOf( "." ) > -1 ) {

            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split( "." );
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf( ":" ) < 0 && "on" + type;

          // Caller can pass in a jQuery.Event object, Object, or just an event type string
          event = event[ jQuery.expando ] ?
            event :
            new jQuery.Event( type, typeof event === "object" && event );

          // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join( "." );
          event.rnamespace = event.namespace ?
            new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
            null;

          // Clean up the event in case it is being reused
          event.result = undefined;
          if ( !event.target ) {
            event.target = elem;
          }

          // Clone any incoming data and prepend the event, creating the handler arg list
          data = data == null ?
            [ event ] :
            jQuery.makeArray( data, [ event ] );

          // Allow special events to draw outside the lines
          special = jQuery.event.special[ type ] || {};
          if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
            return;
          }

          // Determine event propagation path in advance, per W3C events spec (#9951)
          // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
          if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

            bubbleType = special.delegateType || type;
            if ( !rfocusMorph.test( bubbleType + type ) ) {
              cur = cur.parentNode;
            }
            for ( ; cur; cur = cur.parentNode ) {
              eventPath.push( cur );
              tmp = cur;
            }

            // Only add window if we got to document (e.g., not plain obj or detached DOM)
            if ( tmp === ( elem.ownerDocument || document ) ) {
              eventPath.push( tmp.defaultView || tmp.parentWindow || window );
            }
          }

          // Fire handlers on the event path
          i = 0;
          while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
            lastElement = cur;
            event.type = i > 1 ?
              bubbleType :
              special.bindType || type;

            // jQuery handler
            handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
              dataPriv.get( cur, "handle" );
            if ( handle ) {
              handle.apply( cur, data );
            }

            // Native handler
            handle = ontype && cur[ ontype ];
            if ( handle && handle.apply && acceptData( cur ) ) {
              event.result = handle.apply( cur, data );
              if ( event.result === false ) {
                event.preventDefault();
              }
            }
          }
          event.type = type;

          // If nobody prevented the default action, do it now
          if ( !onlyHandlers && !event.isDefaultPrevented() ) {

            if ( ( !special._default ||
              special._default.apply( eventPath.pop(), data ) === false ) &&
              acceptData( elem ) ) {

              // Call a native DOM method on the target with the same name as the event.
              // Don't do default actions on window, that's where global variables be (#6170)
              if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

                // Don't re-trigger an onFOO event when we call its FOO() method
                tmp = elem[ ontype ];

                if ( tmp ) {
                  elem[ ontype ] = null;
                }

                // Prevent re-triggering of the same event, since we already bubbled it above
                jQuery.event.triggered = type;

                if ( event.isPropagationStopped() ) {
                  lastElement.addEventListener( type, stopPropagationCallback );
                }

                elem[ type ]();

                if ( event.isPropagationStopped() ) {
                  lastElement.removeEventListener( type, stopPropagationCallback );
                }

                jQuery.event.triggered = undefined;

                if ( tmp ) {
                  elem[ ontype ] = tmp;
                }
              }
            }
          }

          return event.result;
        },

        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function( type, elem, event ) {
          var e = jQuery.extend(
            new jQuery.Event(),
            event,
            {
              type: type,
              isSimulated: true
            }
          );

          jQuery.event.trigger( e, null, elem );
        }

      } );

      jQuery.fn.extend( {

        trigger: function( type, data ) {
          return this.each( function() {
            jQuery.event.trigger( type, data, this );
          } );
        },
        triggerHandler: function( type, data ) {
          var elem = this[ 0 ];
          if ( elem ) {
            return jQuery.event.trigger( type, data, elem, true );
          }
        }
      } );


      // Support: Firefox <=44
      // Firefox doesn't have focus(in | out) events
      // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
      //
      // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
      // focus(in | out) events fire after focus & blur events,
      // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
      // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
      if ( !support.focusin ) {
        jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

          // Attach a single capturing handler on the document while someone wants focusin/focusout
          var handler = function( event ) {
            jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
          };

          jQuery.event.special[ fix ] = {
            setup: function() {
              var doc = this.ownerDocument || this,
                attaches = dataPriv.access( doc, fix );

              if ( !attaches ) {
                doc.addEventListener( orig, handler, true );
              }
              dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
            },
            teardown: function() {
              var doc = this.ownerDocument || this,
                attaches = dataPriv.access( doc, fix ) - 1;

              if ( !attaches ) {
                doc.removeEventListener( orig, handler, true );
                dataPriv.remove( doc, fix );

              } else {
                dataPriv.access( doc, fix, attaches );
              }
            }
          };
        } );
      }
      var location = window.location;

      var nonce = Date.now();

      var rquery = ( /\?/ );



      // Cross-browser xml parsing
      jQuery.parseXML = function( data ) {
        var xml;
        if ( !data || typeof data !== "string" ) {
          return null;
        }

        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
          xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
        } catch ( e ) {
          xml = undefined;
        }

        if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
          jQuery.error( "Invalid XML: " + data );
        }
        return xml;
      };


      var
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

      function buildParams( prefix, obj, traditional, add ) {
        var name;

        if ( Array.isArray( obj ) ) {

          // Serialize array item.
          jQuery.each( obj, function( i, v ) {
            if ( traditional || rbracket.test( prefix ) ) {

              // Treat each array item as a scalar.
              add( prefix, v );

            } else {

              // Item is non-scalar (array or object), encode its numeric index.
              buildParams(
                prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
                v,
                traditional,
                add
              );
            }
          } );

        } else if ( !traditional && toType( obj ) === "object" ) {

          // Serialize object item.
          for ( name in obj ) {
            buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
          }

        } else {

          // Serialize scalar item.
          add( prefix, obj );
        }
      }

      // Serialize an array of form elements or a set of
      // key/values into a query string
      jQuery.param = function( a, traditional ) {
        var prefix,
          s = [],
          add = function( key, valueOrFunction ) {

            // If value is a function, invoke it and use its return value
            var value = isFunction( valueOrFunction ) ?
              valueOrFunction() :
              valueOrFunction;

            s[ s.length ] = encodeURIComponent( key ) + "=" +
              encodeURIComponent( value == null ? "" : value );
          };

        if ( a == null ) {
          return "";
        }

        // If an array was passed in, assume that it is an array of form elements.
        if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

          // Serialize the form elements
          jQuery.each( a, function() {
            add( this.name, this.value );
          } );

        } else {

          // If traditional, encode the "old" way (the way 1.3.2 or older
          // did it), otherwise encode params recursively.
          for ( prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
          }
        }

        // Return the resulting serialization
        return s.join( "&" );
      };

      jQuery.fn.extend( {
        serialize: function() {
          return jQuery.param( this.serializeArray() );
        },
        serializeArray: function() {
          return this.map( function() {

            // Can add propHook for "elements" to filter or add form elements
            var elements = jQuery.prop( this, "elements" );
            return elements ? jQuery.makeArray( elements ) : this;
          } )
          .filter( function() {
            var type = this.type;

            // Use .is( ":disabled" ) so that fieldset[disabled] works
            return this.name && !jQuery( this ).is( ":disabled" ) &&
              rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
              ( this.checked || !rcheckableType.test( type ) );
          } )
          .map( function( i, elem ) {
            var val = jQuery( this ).val();

            if ( val == null ) {
              return null;
            }

            if ( Array.isArray( val ) ) {
              return jQuery.map( val, function( val ) {
                return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
              } );
            }

            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
          } ).get();
        }
      } );


      var
        r20 = /%20/g,
        rhash = /#.*$/,
        rantiCache = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,

        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},

        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat( "*" ),

        // Anchor tag for parsing the document origin
        originAnchor = document.createElement( "a" );
        originAnchor.href = location.href;

      // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
      function addToPrefiltersOrTransports( structure ) {

        // dataTypeExpression is optional and defaults to "*"
        return function( dataTypeExpression, func ) {

          if ( typeof dataTypeExpression !== "string" ) {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }

          var dataType,
            i = 0,
            dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

          if ( isFunction( func ) ) {

            // For each dataType in the dataTypeExpression
            while ( ( dataType = dataTypes[ i++ ] ) ) {

              // Prepend if requested
              if ( dataType[ 0 ] === "+" ) {
                dataType = dataType.slice( 1 ) || "*";
                ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

              // Otherwise append
              } else {
                ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
              }
            }
          }
        };
      }

      // Base inspection function for prefilters and transports
      function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

        var inspected = {},
          seekingTransport = ( structure === transports );

        function inspect( dataType ) {
          var selected;
          inspected[ dataType ] = true;
          jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
            if ( typeof dataTypeOrTransport === "string" &&
              !seekingTransport && !inspected[ dataTypeOrTransport ] ) {

              options.dataTypes.unshift( dataTypeOrTransport );
              inspect( dataTypeOrTransport );
              return false;
            } else if ( seekingTransport ) {
              return !( selected = dataTypeOrTransport );
            }
          } );
          return selected;
        }

        return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
      }

      // A special extend for ajax options
      // that takes "flat" options (not to be deep extended)
      // Fixes #9887
      function ajaxExtend( target, src ) {
        var key, deep,
          flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for ( key in src ) {
          if ( src[ key ] !== undefined ) {
            ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
          }
        }
        if ( deep ) {
          jQuery.extend( true, target, deep );
        }

        return target;
      }

      /* Handles responses to an ajax request:
       * - finds the right dataType (mediates between content-type and expected dataType)
       * - returns the corresponding response
       */
      function ajaxHandleResponses( s, jqXHR, responses ) {

        var ct, type, finalDataType, firstDataType,
          contents = s.contents,
          dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while ( dataTypes[ 0 ] === "*" ) {
          dataTypes.shift();
          if ( ct === undefined ) {
            ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
          }
        }

        // Check if we're dealing with a known content-type
        if ( ct ) {
          for ( type in contents ) {
            if ( contents[ type ] && contents[ type ].test( ct ) ) {
              dataTypes.unshift( type );
              break;
            }
          }
        }

        // Check to see if we have a response for the expected dataType
        if ( dataTypes[ 0 ] in responses ) {
          finalDataType = dataTypes[ 0 ];
        } else {

          // Try convertible dataTypes
          for ( type in responses ) {
            if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
              finalDataType = type;
              break;
            }
            if ( !firstDataType ) {
              firstDataType = type;
            }
          }

          // Or just use first one
          finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if ( finalDataType ) {
          if ( finalDataType !== dataTypes[ 0 ] ) {
            dataTypes.unshift( finalDataType );
          }
          return responses[ finalDataType ];
        }
      }

      /* Chain conversions given the request and the original response
       * Also sets the responseXXX fields on the jqXHR instance
       */
      function ajaxConvert( s, response, jqXHR, isSuccess ) {
        var conv2, current, conv, tmp, prev,
          converters = {},

          // Work with a copy of dataTypes in case we need to modify it for conversion
          dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if ( dataTypes[ 1 ] ) {
          for ( conv in s.converters ) {
            converters[ conv.toLowerCase() ] = s.converters[ conv ];
          }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while ( current ) {

          if ( s.responseFields[ current ] ) {
            jqXHR[ s.responseFields[ current ] ] = response;
          }

          // Apply the dataFilter if provided
          if ( !prev && isSuccess && s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
          }

          prev = current;
          current = dataTypes.shift();

          if ( current ) {

            // There's only work to do if current dataType is non-auto
            if ( current === "*" ) {

              current = prev;

            // Convert response if prev dataType is non-auto and differs from current
            } else if ( prev !== "*" && prev !== current ) {

              // Seek a direct converter
              conv = converters[ prev + " " + current ] || converters[ "* " + current ];

              // If none found, seek a pair
              if ( !conv ) {
                for ( conv2 in converters ) {

                  // If conv2 outputs current
                  tmp = conv2.split( " " );
                  if ( tmp[ 1 ] === current ) {

                    // If prev can be converted to accepted input
                    conv = converters[ prev + " " + tmp[ 0 ] ] ||
                      converters[ "* " + tmp[ 0 ] ];
                    if ( conv ) {

                      // Condense equivalence converters
                      if ( conv === true ) {
                        conv = converters[ conv2 ];

                      // Otherwise, insert the intermediate dataType
                      } else if ( converters[ conv2 ] !== true ) {
                        current = tmp[ 0 ];
                        dataTypes.unshift( tmp[ 1 ] );
                      }
                      break;
                    }
                  }
                }
              }

              // Apply converter (if not an equivalence)
              if ( conv !== true ) {

                // Unless errors are allowed to bubble, catch and return them
                if ( conv && s.throws ) {
                  response = conv( response );
                } else {
                  try {
                    response = conv( response );
                  } catch ( e ) {
                    return {
                      state: "parsererror",
                      error: conv ? e : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }

        return { state: "success", data: response };
      }

      jQuery.extend( {

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
          url: location.href,
          type: "GET",
          isLocal: rlocalProtocol.test( location.protocol ),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",

          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */

          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },

          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },

          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },

          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {

            // Convert anything to text
            "* text": String,

            // Text to html (true = no transformation)
            "text html": true,

            // Evaluate text as a json expression
            "text json": JSON.parse,

            // Parse text as xml
            "text xml": jQuery.parseXML
          },

          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function( target, settings ) {
          return settings ?

            // Building a settings object
            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

            // Extending ajaxSettings
            ajaxExtend( jQuery.ajaxSettings, target );
        },

        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),

        // Main method
        ajax: function( url, options ) {

          // If url is an object, simulate pre-1.5 signature
          if ( typeof url === "object" ) {
            options = url;
            url = undefined;
          }

          // Force options to be an object
          options = options || {};

          var transport,

            // URL without anti-cache param
            cacheURL,

            // Response headers
            responseHeadersString,
            responseHeaders,

            // timeout handle
            timeoutTimer,

            // Url cleanup var
            urlAnchor,

            // Request state (becomes false upon send and true upon completion)
            completed,

            // To know if global events are to be dispatched
            fireGlobals,

            // Loop variable
            i,

            // uncached part of the url
            uncached,

            // Create the final options object
            s = jQuery.ajaxSetup( {}, options ),

            // Callbacks context
            callbackContext = s.context || s,

            // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context &&
              ( callbackContext.nodeType || callbackContext.jquery ) ?
                jQuery( callbackContext ) :
                jQuery.event,

            // Deferreds
            deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks( "once memory" ),

            // Status-dependent callbacks
            statusCode = s.statusCode || {},

            // Headers (they are sent all at once)
            requestHeaders = {},
            requestHeadersNames = {},

            // Default abort message
            strAbort = "canceled",

            // Fake xhr
            jqXHR = {
              readyState: 0,

              // Builds headers hashtable if needed
              getResponseHeader: function( key ) {
                var match;
                if ( completed ) {
                  if ( !responseHeaders ) {
                    responseHeaders = {};
                    while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                      responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
                        ( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
                          .concat( match[ 2 ] );
                    }
                  }
                  match = responseHeaders[ key.toLowerCase() + " " ];
                }
                return match == null ? null : match.join( ", " );
              },

              // Raw string
              getAllResponseHeaders: function() {
                return completed ? responseHeadersString : null;
              },

              // Caches the header
              setRequestHeader: function( name, value ) {
                if ( completed == null ) {
                  name = requestHeadersNames[ name.toLowerCase() ] =
                    requestHeadersNames[ name.toLowerCase() ] || name;
                  requestHeaders[ name ] = value;
                }
                return this;
              },

              // Overrides response content-type header
              overrideMimeType: function( type ) {
                if ( completed == null ) {
                  s.mimeType = type;
                }
                return this;
              },

              // Status-dependent callbacks
              statusCode: function( map ) {
                var code;
                if ( map ) {
                  if ( completed ) {

                    // Execute the appropriate callbacks
                    jqXHR.always( map[ jqXHR.status ] );
                  } else {

                    // Lazy-add the new callbacks in a way that preserves old ones
                    for ( code in map ) {
                      statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                    }
                  }
                }
                return this;
              },

              // Cancel the request
              abort: function( statusText ) {
                var finalText = statusText || strAbort;
                if ( transport ) {
                  transport.abort( finalText );
                }
                done( 0, finalText );
                return this;
              }
            };

          // Attach deferreds
          deferred.promise( jqXHR );

          // Add protocol if not provided (prefilters might expect it)
          // Handle falsy url in the settings object (#10093: consistency with old signature)
          // We also use the url parameter if available
          s.url = ( ( url || s.url || location.href ) + "" )
            .replace( rprotocol, location.protocol + "//" );

          // Alias method option to type as per ticket #12004
          s.type = options.method || options.type || s.method || s.type;

          // Extract dataTypes list
          s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

          // A cross-domain request is in order when the origin doesn't match the current origin.
          if ( s.crossDomain == null ) {
            urlAnchor = document.createElement( "a" );

            // Support: IE <=8 - 11, Edge 12 - 15
            // IE throws exception on accessing the href property if url is malformed,
            // e.g. http://example.com:80x/
            try {
              urlAnchor.href = s.url;

              // Support: IE <=8 - 11 only
              // Anchor's host property isn't correctly set when s.url is relative
              urlAnchor.href = urlAnchor.href;
              s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                urlAnchor.protocol + "//" + urlAnchor.host;
            } catch ( e ) {

              // If there is an error parsing the URL, assume it is crossDomain,
              // it can be rejected by the transport if it is invalid
              s.crossDomain = true;
            }
          }

          // Convert data if not already a string
          if ( s.data && s.processData && typeof s.data !== "string" ) {
            s.data = jQuery.param( s.data, s.traditional );
          }

          // Apply prefilters
          inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

          // If request was aborted inside a prefilter, stop there
          if ( completed ) {
            return jqXHR;
          }

          // We can fire global events as of now if asked to
          // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
          fireGlobals = jQuery.event && s.global;

          // Watch for a new set of requests
          if ( fireGlobals && jQuery.active++ === 0 ) {
            jQuery.event.trigger( "ajaxStart" );
          }

          // Uppercase the type
          s.type = s.type.toUpperCase();

          // Determine if request has content
          s.hasContent = !rnoContent.test( s.type );

          // Save the URL in case we're toying with the If-Modified-Since
          // and/or If-None-Match header later on
          // Remove hash to simplify url manipulation
          cacheURL = s.url.replace( rhash, "" );

          // More options handling for requests with no content
          if ( !s.hasContent ) {

            // Remember the hash so we can put it back
            uncached = s.url.slice( cacheURL.length );

            // If data is available and should be processed, append data to url
            if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
              cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

              // #9682: remove data so that it's not used in an eventual retry
              delete s.data;
            }

            // Add or update anti-cache param if needed
            if ( s.cache === false ) {
              cacheURL = cacheURL.replace( rantiCache, "$1" );
              uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
            }

            // Put hash and anti-cache on the URL that will be requested (gh-1732)
            s.url = cacheURL + uncached;

          // Change '%20' to '+' if this is encoded form body content (gh-2658)
          } else if ( s.data && s.processData &&
            ( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
            s.data = s.data.replace( r20, "+" );
          }

          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if ( s.ifModified ) {
            if ( jQuery.lastModified[ cacheURL ] ) {
              jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
            }
            if ( jQuery.etag[ cacheURL ] ) {
              jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
            }
          }

          // Set the correct header, if data is being sent
          if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
            jqXHR.setRequestHeader( "Content-Type", s.contentType );
          }

          // Set the Accepts header for the server, depending on the dataType
          jqXHR.setRequestHeader(
            "Accept",
            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
              s.accepts[ s.dataTypes[ 0 ] ] +
                ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
              s.accepts[ "*" ]
          );

          // Check for headers option
          for ( i in s.headers ) {
            jqXHR.setRequestHeader( i, s.headers[ i ] );
          }

          // Allow custom headers/mimetypes and early abort
          if ( s.beforeSend &&
            ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

            // Abort if not done already and return
            return jqXHR.abort();
          }

          // Aborting is no longer a cancellation
          strAbort = "abort";

          // Install callbacks on deferreds
          completeDeferred.add( s.complete );
          jqXHR.done( s.success );
          jqXHR.fail( s.error );

          // Get transport
          transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

          // If no transport, we auto-abort
          if ( !transport ) {
            done( -1, "No Transport" );
          } else {
            jqXHR.readyState = 1;

            // Send global event
            if ( fireGlobals ) {
              globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
            }

            // If request was aborted inside ajaxSend, stop there
            if ( completed ) {
              return jqXHR;
            }

            // Timeout
            if ( s.async && s.timeout > 0 ) {
              timeoutTimer = window.setTimeout( function() {
                jqXHR.abort( "timeout" );
              }, s.timeout );
            }

            try {
              completed = false;
              transport.send( requestHeaders, done );
            } catch ( e ) {

              // Rethrow post-completion exceptions
              if ( completed ) {
                throw e;
              }

              // Propagate others as results
              done( -1, e );
            }
          }

          // Callback for when everything is done
          function done( status, nativeStatusText, responses, headers ) {
            var isSuccess, success, error, response, modified,
              statusText = nativeStatusText;

            // Ignore repeat invocations
            if ( completed ) {
              return;
            }

            completed = true;

            // Clear timeout if it exists
            if ( timeoutTimer ) {
              window.clearTimeout( timeoutTimer );
            }

            // Dereference transport for early garbage collection
            // (no matter how long the jqXHR object will be used)
            transport = undefined;

            // Cache response headers
            responseHeadersString = headers || "";

            // Set readyState
            jqXHR.readyState = status > 0 ? 4 : 0;

            // Determine if successful
            isSuccess = status >= 200 && status < 300 || status === 304;

            // Get response data
            if ( responses ) {
              response = ajaxHandleResponses( s, jqXHR, responses );
            }

            // Convert no matter what (that way responseXXX fields are always set)
            response = ajaxConvert( s, response, jqXHR, isSuccess );

            // If successful, handle type chaining
            if ( isSuccess ) {

              // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
              if ( s.ifModified ) {
                modified = jqXHR.getResponseHeader( "Last-Modified" );
                if ( modified ) {
                  jQuery.lastModified[ cacheURL ] = modified;
                }
                modified = jqXHR.getResponseHeader( "etag" );
                if ( modified ) {
                  jQuery.etag[ cacheURL ] = modified;
                }
              }

              // if no content
              if ( status === 204 || s.type === "HEAD" ) {
                statusText = "nocontent";

              // if not modified
              } else if ( status === 304 ) {
                statusText = "notmodified";

              // If we have data, let's convert it
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {

              // Extract error from statusText and normalize for non-aborts
              error = statusText;
              if ( status || !statusText ) {
                statusText = "error";
                if ( status < 0 ) {
                  status = 0;
                }
              }
            }

            // Set data for the fake xhr object
            jqXHR.status = status;
            jqXHR.statusText = ( nativeStatusText || statusText ) + "";

            // Success/Error
            if ( isSuccess ) {
              deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
            } else {
              deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
            }

            // Status-dependent callbacks
            jqXHR.statusCode( statusCode );
            statusCode = undefined;

            if ( fireGlobals ) {
              globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                [ jqXHR, s, isSuccess ? success : error ] );
            }

            // Complete
            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

            if ( fireGlobals ) {
              globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

              // Handle the global AJAX counter
              if ( !( --jQuery.active ) ) {
                jQuery.event.trigger( "ajaxStop" );
              }
            }
          }

          return jqXHR;
        },

        getJSON: function( url, data, callback ) {
          return jQuery.get( url, data, callback, "json" );
        },

        getScript: function( url, callback ) {
          return jQuery.get( url, undefined, callback, "script" );
        }
      } );

      jQuery.each( [ "get", "post" ], function( i, method ) {
        jQuery[ method ] = function( url, data, callback, type ) {

          // Shift arguments if data argument was omitted
          if ( isFunction( data ) ) {
            type = type || callback;
            callback = data;
            data = undefined;
          }

          // The url can be an options object (which then must have .url)
          return jQuery.ajax( jQuery.extend( {
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
          }, jQuery.isPlainObject( url ) && url ) );
        };
      } );


      jQuery._evalUrl = function( url, options ) {
        return jQuery.ajax( {
          url: url,

          // Make this explicit, since user can override this through ajaxSetup (#11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,

          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function() {}
          },
          dataFilter: function( response ) {
            jQuery.globalEval( response, options );
          }
        } );
      };


      jQuery.fn.extend( {
        wrapAll: function( html ) {
          var wrap;

          if ( this[ 0 ] ) {
            if ( isFunction( html ) ) {
              html = html.call( this[ 0 ] );
            }

            // The elements to wrap the target around
            wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

            if ( this[ 0 ].parentNode ) {
              wrap.insertBefore( this[ 0 ] );
            }

            wrap.map( function() {
              var elem = this;

              while ( elem.firstElementChild ) {
                elem = elem.firstElementChild;
              }

              return elem;
            } ).append( this );
          }

          return this;
        },

        wrapInner: function( html ) {
          if ( isFunction( html ) ) {
            return this.each( function( i ) {
              jQuery( this ).wrapInner( html.call( this, i ) );
            } );
          }

          return this.each( function() {
            var self = jQuery( this ),
              contents = self.contents();

            if ( contents.length ) {
              contents.wrapAll( html );

            } else {
              self.append( html );
            }
          } );
        },

        wrap: function( html ) {
          var htmlIsFunction = isFunction( html );

          return this.each( function( i ) {
            jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
          } );
        },

        unwrap: function( selector ) {
          this.parent( selector ).not( "body" ).each( function() {
            jQuery( this ).replaceWith( this.childNodes );
          } );
          return this;
        }
      } );


      jQuery.expr.pseudos.hidden = function( elem ) {
        return !jQuery.expr.pseudos.visible( elem );
      };
      jQuery.expr.pseudos.visible = function( elem ) {
        return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
      };




      jQuery.ajaxSettings.xhr = function() {
        try {
          return new window.XMLHttpRequest();
        } catch ( e ) {}
      };

      var xhrSuccessStatus = {

          // File protocol always yields status code 0, assume 200
          0: 200,

          // Support: IE <=9 only
          // #1450: sometimes IE returns 1223 when it should be 204
          1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();

      support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
      support.ajax = xhrSupported = !!xhrSupported;

      jQuery.ajaxTransport( function( options ) {
        var callback, errorCallback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if ( support.cors || xhrSupported && !options.crossDomain ) {
          return {
            send: function( headers, complete ) {
              var i,
                xhr = options.xhr();

              xhr.open(
                options.type,
                options.url,
                options.async,
                options.username,
                options.password
              );

              // Apply custom fields if provided
              if ( options.xhrFields ) {
                for ( i in options.xhrFields ) {
                  xhr[ i ] = options.xhrFields[ i ];
                }
              }

              // Override mime type if needed
              if ( options.mimeType && xhr.overrideMimeType ) {
                xhr.overrideMimeType( options.mimeType );
              }

              // X-Requested-With header
              // For cross-domain requests, seeing as conditions for a preflight are
              // akin to a jigsaw puzzle, we simply never set it to be sure.
              // (it can always be set on a per-request basis or even using ajaxSetup)
              // For same-domain requests, won't change header if already provided.
              if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
                headers[ "X-Requested-With" ] = "XMLHttpRequest";
              }

              // Set headers
              for ( i in headers ) {
                xhr.setRequestHeader( i, headers[ i ] );
              }

              // Callback
              callback = function( type ) {
                return function() {
                  if ( callback ) {
                    callback = errorCallback = xhr.onload =
                      xhr.onerror = xhr.onabort = xhr.ontimeout =
                        xhr.onreadystatechange = null;

                    if ( type === "abort" ) {
                      xhr.abort();
                    } else if ( type === "error" ) {

                      // Support: IE <=9 only
                      // On a manual native abort, IE9 throws
                      // errors on any property access that is not readyState
                      if ( typeof xhr.status !== "number" ) {
                        complete( 0, "error" );
                      } else {
                        complete(

                          // File: protocol always yields status 0; see #8605, #14207
                          xhr.status,
                          xhr.statusText
                        );
                      }
                    } else {
                      complete(
                        xhrSuccessStatus[ xhr.status ] || xhr.status,
                        xhr.statusText,

                        // Support: IE <=9 only
                        // IE9 has no XHR2 but throws on binary (trac-11426)
                        // For XHR2 non-text, let the caller handle it (gh-2498)
                        ( xhr.responseType || "text" ) !== "text"  ||
                        typeof xhr.responseText !== "string" ?
                          { binary: xhr.response } :
                          { text: xhr.responseText },
                        xhr.getAllResponseHeaders()
                      );
                    }
                  }
                };
              };

              // Listen to events
              xhr.onload = callback();
              errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

              // Support: IE 9 only
              // Use onreadystatechange to replace onabort
              // to handle uncaught aborts
              if ( xhr.onabort !== undefined ) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {

                  // Check readyState before timeout as it changes
                  if ( xhr.readyState === 4 ) {

                    // Allow onerror to be called first,
                    // but that will not handle a native abort
                    // Also, save errorCallback to a variable
                    // as xhr.onerror cannot be accessed
                    window.setTimeout( function() {
                      if ( callback ) {
                        errorCallback();
                      }
                    } );
                  }
                };
              }

              // Create the abort callback
              callback = callback( "abort" );

              try {

                // Do send the request (this may raise an exception)
                xhr.send( options.hasContent && options.data || null );
              } catch ( e ) {

                // #14683: Only rethrow if this hasn't been notified as an error yet
                if ( callback ) {
                  throw e;
                }
              }
            },

            abort: function() {
              if ( callback ) {
                callback();
              }
            }
          };
        }
      } );




      // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
      jQuery.ajaxPrefilter( function( s ) {
        if ( s.crossDomain ) {
          s.contents.script = false;
        }
      } );

      // Install script dataType
      jQuery.ajaxSetup( {
        accepts: {
          script: "text/javascript, application/javascript, " +
            "application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function( text ) {
            jQuery.globalEval( text );
            return text;
          }
        }
      } );

      // Handle cache's special case and crossDomain
      jQuery.ajaxPrefilter( "script", function( s ) {
        if ( s.cache === undefined ) {
          s.cache = false;
        }
        if ( s.crossDomain ) {
          s.type = "GET";
        }
      } );

      // Bind script tag hack transport
      jQuery.ajaxTransport( "script", function( s ) {

        // This transport only deals with cross domain or forced-by-attrs requests
        if ( s.crossDomain || s.scriptAttrs ) {
          var script, callback;
          return {
            send: function( _, complete ) {
              script = jQuery( "<script>" )
                .attr( s.scriptAttrs || {} )
                .prop( { charset: s.scriptCharset, src: s.url } )
                .on( "load error", callback = function( evt ) {
                  script.remove();
                  callback = null;
                  if ( evt ) {
                    complete( evt.type === "error" ? 404 : 200, evt.type );
                  }
                } );

              // Use native DOM manipulation to avoid our domManip AJAX trickery
              document.head.appendChild( script[ 0 ] );
            },
            abort: function() {
              if ( callback ) {
                callback();
              }
            }
          };
        }
      } );




      var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

      // Default jsonp settings
      jQuery.ajaxSetup( {
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
          this[ callback ] = true;
          return callback;
        }
      } );

      // Detect, normalize options and install callbacks for jsonp requests
      jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

        var callbackName, overwritten, responseContainer,
          jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
            "url" :
            typeof s.data === "string" &&
              ( s.contentType || "" )
                .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
              rjsonp.test( s.data ) && "data"
          );

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

          // Get callback name, remembering preexisting value associated with it
          callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
            s.jsonpCallback() :
            s.jsonpCallback;

          // Insert callback into url or form data
          if ( jsonProp ) {
            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
          } else if ( s.jsonp !== false ) {
            s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
          }

          // Use data converter to retrieve json after script execution
          s.converters[ "script json" ] = function() {
            if ( !responseContainer ) {
              jQuery.error( callbackName + " was not called" );
            }
            return responseContainer[ 0 ];
          };

          // Force json dataType
          s.dataTypes[ 0 ] = "json";

          // Install callback
          overwritten = window[ callbackName ];
          window[ callbackName ] = function() {
            responseContainer = arguments;
          };

          // Clean-up function (fires after converters)
          jqXHR.always( function() {

            // If previous value didn't exist - remove it
            if ( overwritten === undefined ) {
              jQuery( window ).removeProp( callbackName );

            // Otherwise restore preexisting value
            } else {
              window[ callbackName ] = overwritten;
            }

            // Save back as free
            if ( s[ callbackName ] ) {

              // Make sure that re-using the options doesn't screw things around
              s.jsonpCallback = originalSettings.jsonpCallback;

              // Save the callback name for future use
              oldCallbacks.push( callbackName );
            }

            // Call if it was a function and we have a response
            if ( responseContainer && isFunction( overwritten ) ) {
              overwritten( responseContainer[ 0 ] );
            }

            responseContainer = overwritten = undefined;
          } );

          // Delegate to script
          return "script";
        }
      } );




      // Support: Safari 8 only
      // In Safari 8 documents created via document.implementation.createHTMLDocument
      // collapse sibling forms: the second one becomes a child of the first one.
      // Because of that, this security measure has to be disabled in Safari 8.
      // https://bugs.webkit.org/show_bug.cgi?id=137337
      support.createHTMLDocument = ( function() {
        var body = document.implementation.createHTMLDocument( "" ).body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      } )();


      // Argument "data" should be string of html
      // context (optional): If specified, the fragment will be created in this context,
      // defaults to document
      // keepScripts (optional): If true, will include scripts passed in the html string
      jQuery.parseHTML = function( data, context, keepScripts ) {
        if ( typeof data !== "string" ) {
          return [];
        }
        if ( typeof context === "boolean" ) {
          keepScripts = context;
          context = false;
        }

        var base, parsed, scripts;

        if ( !context ) {

          // Stop scripts or inline event handlers from being executed immediately
          // by using document.implementation
          if ( support.createHTMLDocument ) {
            context = document.implementation.createHTMLDocument( "" );

            // Set the base href for the created document
            // so any parsed elements with URLs
            // are based on the document's URL (gh-2965)
            base = context.createElement( "base" );
            base.href = document.location.href;
            context.head.appendChild( base );
          } else {
            context = document;
          }
        }

        parsed = rsingleTag.exec( data );
        scripts = !keepScripts && [];

        // Single tag
        if ( parsed ) {
          return [ context.createElement( parsed[ 1 ] ) ];
        }

        parsed = buildFragment( [ data ], context, scripts );

        if ( scripts && scripts.length ) {
          jQuery( scripts ).remove();
        }

        return jQuery.merge( [], parsed.childNodes );
      };


      /**
       * Load a url into a page
       */
      jQuery.fn.load = function( url, params, callback ) {
        var selector, type, response,
          self = this,
          off = url.indexOf( " " );

        if ( off > -1 ) {
          selector = stripAndCollapse( url.slice( off ) );
          url = url.slice( 0, off );
        }

        // If it's a function
        if ( isFunction( params ) ) {

          // We assume that it's the callback
          callback = params;
          params = undefined;

        // Otherwise, build a param string
        } else if ( params && typeof params === "object" ) {
          type = "POST";
        }

        // If we have elements to modify, make the request
        if ( self.length > 0 ) {
          jQuery.ajax( {
            url: url,

            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
          } ).done( function( responseText ) {

            // Save response for use in complete callback
            response = arguments;

            self.html( selector ?

              // If a selector was specified, locate the right elements in a dummy div
              // Exclude scripts to avoid IE 'Permission Denied' errors
              jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

              // Otherwise use the full result
              responseText );

          // If the request succeeds, this function gets "data", "status", "jqXHR"
          // but they are ignored because response was set above.
          // If it fails, this function gets "jqXHR", "status", "error"
          } ).always( callback && function( jqXHR, status ) {
            self.each( function() {
              callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
            } );
          } );
        }

        return this;
      };




      // Attach a bunch of functions for handling common AJAX events
      jQuery.each( [
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
      ], function( i, type ) {
        jQuery.fn[ type ] = function( fn ) {
          return this.on( type, fn );
        };
      } );




      jQuery.expr.pseudos.animated = function( elem ) {
        return jQuery.grep( jQuery.timers, function( fn ) {
          return elem === fn.elem;
        } ).length;
      };




      jQuery.offset = {
        setOffset: function( elem, options, i ) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
            position = jQuery.css( elem, "position" ),
            curElem = jQuery( elem ),
            props = {};

          // Set position first, in-case top/left are set even on static elem
          if ( position === "static" ) {
            elem.style.position = "relative";
          }

          curOffset = curElem.offset();
          curCSSTop = jQuery.css( elem, "top" );
          curCSSLeft = jQuery.css( elem, "left" );
          calculatePosition = ( position === "absolute" || position === "fixed" ) &&
            ( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

          // Need to be able to calculate position if either
          // top or left is auto and position is either absolute or fixed
          if ( calculatePosition ) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;

          } else {
            curTop = parseFloat( curCSSTop ) || 0;
            curLeft = parseFloat( curCSSLeft ) || 0;
          }

          if ( isFunction( options ) ) {

            // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
            options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
          }

          if ( options.top != null ) {
            props.top = ( options.top - curOffset.top ) + curTop;
          }
          if ( options.left != null ) {
            props.left = ( options.left - curOffset.left ) + curLeft;
          }

          if ( "using" in options ) {
            options.using.call( elem, props );

          } else {
            curElem.css( props );
          }
        }
      };

      jQuery.fn.extend( {

        // offset() relates an element's border box to the document origin
        offset: function( options ) {

          // Preserve chaining for setter
          if ( arguments.length ) {
            return options === undefined ?
              this :
              this.each( function( i ) {
                jQuery.offset.setOffset( this, options, i );
              } );
          }

          var rect, win,
            elem = this[ 0 ];

          if ( !elem ) {
            return;
          }

          // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
          // Support: IE <=11 only
          // Running getBoundingClientRect on a
          // disconnected node in IE throws an error
          if ( !elem.getClientRects().length ) {
            return { top: 0, left: 0 };
          }

          // Get document-relative position by adding viewport scroll to viewport-relative gBCR
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },

        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
          if ( !this[ 0 ] ) {
            return;
          }

          var offsetParent, offset, doc,
            elem = this[ 0 ],
            parentOffset = { top: 0, left: 0 };

          // position:fixed elements are offset from the viewport, which itself always has zero offset
          if ( jQuery.css( elem, "position" ) === "fixed" ) {

            // Assume position:fixed implies availability of getBoundingClientRect
            offset = elem.getBoundingClientRect();

          } else {
            offset = this.offset();

            // Account for the *real* offset parent, which can be the document or its root element
            // when a statically positioned element is identified
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while ( offsetParent &&
              ( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
              jQuery.css( offsetParent, "position" ) === "static" ) {

              offsetParent = offsetParent.parentNode;
            }
            if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

              // Incorporate borders into its offset, since they are outside its content origin
              parentOffset = jQuery( offsetParent ).offset();
              parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
              parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
            }
          }

          // Subtract parent offsets and element margins
          return {
            top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
            left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
          };
        },

        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
          return this.map( function() {
            var offsetParent = this.offsetParent;

            while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
              offsetParent = offsetParent.offsetParent;
            }

            return offsetParent || documentElement;
          } );
        }
      } );

      // Create scrollLeft and scrollTop methods
      jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
        var top = "pageYOffset" === prop;

        jQuery.fn[ method ] = function( val ) {
          return access( this, function( elem, method, val ) {

            // Coalesce documents and windows
            var win;
            if ( isWindow( elem ) ) {
              win = elem;
            } else if ( elem.nodeType === 9 ) {
              win = elem.defaultView;
            }

            if ( val === undefined ) {
              return win ? win[ prop ] : elem[ method ];
            }

            if ( win ) {
              win.scrollTo(
                !top ? val : win.pageXOffset,
                top ? val : win.pageYOffset
              );

            } else {
              elem[ method ] = val;
            }
          }, method, val, arguments.length );
        };
      } );

      // Support: Safari <=7 - 9.1, Chrome <=37 - 49
      // Add the top/left cssHooks using jQuery.fn.position
      // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
      // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
      // getComputedStyle returns percent when specified for top/left/bottom/right;
      // rather than make the css module depend on the offset module, just check for it here
      jQuery.each( [ "top", "left" ], function( i, prop ) {
        jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
          function( elem, computed ) {
            if ( computed ) {
              computed = curCSS( elem, prop );

              // If curCSS returns percentage, fallback to offset
              return rnumnonpx.test( computed ) ?
                jQuery( elem ).position()[ prop ] + "px" :
                computed;
            }
          }
        );
      } );


      // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
      jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
        jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
          function( defaultExtra, funcName ) {

          // Margin is only for outerHeight, outerWidth
          jQuery.fn[ funcName ] = function( margin, value ) {
            var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
              extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

            return access( this, function( elem, type, value ) {
              var doc;

              if ( isWindow( elem ) ) {

                // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                return funcName.indexOf( "outer" ) === 0 ?
                  elem[ "inner" + name ] :
                  elem.document.documentElement[ "client" + name ];
              }

              // Get document width or height
              if ( elem.nodeType === 9 ) {
                doc = elem.documentElement;

                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                // whichever is greatest
                return Math.max(
                  elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                  elem.body[ "offset" + name ], doc[ "offset" + name ],
                  doc[ "client" + name ]
                );
              }

              return value === undefined ?

                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery.css( elem, type, extra ) :

                // Set width or height on the element
                jQuery.style( elem, type, value, extra );
            }, type, chainable ? margin : undefined, chainable );
          };
        } );
      } );


      jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup contextmenu" ).split( " " ),
        function( i, name ) {

        // Handle event binding
        jQuery.fn[ name ] = function( data, fn ) {
          return arguments.length > 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
        };
      } );

      jQuery.fn.extend( {
        hover: function( fnOver, fnOut ) {
          return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
        }
      } );




      jQuery.fn.extend( {

        bind: function( types, data, fn ) {
          return this.on( types, null, data, fn );
        },
        unbind: function( types, fn ) {
          return this.off( types, null, fn );
        },

        delegate: function( selector, types, data, fn ) {
          return this.on( types, selector, data, fn );
        },
        undelegate: function( selector, types, fn ) {

          // ( namespace ) or ( selector, types [, fn] )
          return arguments.length === 1 ?
            this.off( selector, "**" ) :
            this.off( types, selector || "**", fn );
        }
      } );

      // Bind a function to a context, optionally partially applying any
      // arguments.
      // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
      // However, it is not slated for removal any time soon
      jQuery.proxy = function( fn, context ) {
        var tmp, args, proxy;

        if ( typeof context === "string" ) {
          tmp = fn[ context ];
          context = fn;
          fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if ( !isFunction( fn ) ) {
          return undefined;
        }

        // Simulated bind
        args = slice.call( arguments, 2 );
        proxy = function() {
          return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
      };

      jQuery.holdReady = function( hold ) {
        if ( hold ) {
          jQuery.readyWait++;
        } else {
          jQuery.ready( true );
        }
      };
      jQuery.isArray = Array.isArray;
      jQuery.parseJSON = JSON.parse;
      jQuery.nodeName = nodeName;
      jQuery.isFunction = isFunction;
      jQuery.isWindow = isWindow;
      jQuery.camelCase = camelCase;
      jQuery.type = toType;

      jQuery.now = Date.now;

      jQuery.isNumeric = function( obj ) {

        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type( obj );
        return ( type === "number" || type === "string" ) &&

          // parseFloat NaNs numeric-cast false positives ("")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          !isNaN( obj - parseFloat( obj ) );
      };




      // Register as a named AMD module, since jQuery can be concatenated with other
      // files that may use define, but not via a proper concatenation script that
      // understands anonymous AMD modules. A named AMD is safest and most robust
      // way to register. Lowercase jquery is used because AMD module names are
      // derived from file names, and jQuery is normally delivered in a lowercase
      // file name. Do this after creating the global so that if an AMD module wants
      // to call noConflict to hide this version of jQuery, it will work.

      // Note that for maximum portability, libraries that are not jQuery should
      // declare themselves as anonymous modules, and avoid setting a global if an
      // AMD loader is present. jQuery is a special case. For more information, see
      // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

      if ( typeof define === "function" && define.amd ) {
        define( "jquery", [], function() {
          return jQuery;
        } );
      }




      var

        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

      jQuery.noConflict = function( deep ) {
        if ( window.$ === jQuery ) {
          window.$ = _$;
        }

        if ( deep && window.jQuery === jQuery ) {
          window.jQuery = _jQuery;
        }

        return jQuery;
      };

      // Expose jQuery and $ identifiers, even in AMD
      // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
      // and CommonJS for browser emulators (#13566)
      if ( !noGlobal ) {
        window.jQuery = window.$ = jQuery;
      }




      return jQuery;
      } );

    </script>
    <script>

        var Sketch=function(){function e(e){e=n(e||{},l);var t="sketch-"+r++,o=e.hasOwnProperty("canvas"),u=o?e.canvas:document.createElement("canvas");switch(e.type){case m:try{s=u.getContext("webgl",e)}catch(d){}try{s=s||u.getContext("experimental-webgl",e)}catch(d){}if(!s)throw"WebGL not supported";break;case c:try{s=u.getContext("2d",e)}catch(d){}if(!s)throw"Canvas not supported";break;default:u=s=document.createElement("div")}return s.canvas=u,u.className="sketch",o?e.autoresize=!1:(e.container.appendChild(u),e.hasOwnProperty("autoresize")||(e.autoresize=l.autoresize),u.id=t),n(self,g),n(s,e),n(s,p),a(),e.autoresize&&i(),w.push(s),s.autostart&&setTimeout(s.start,0),s}function n(e,n){for(var t in n)e.hasOwnProperty(t)||(e[t]=n[t]);return e}function t(e){function n(e,n){return function(){e.call(n,arguments)}}var t={};for(var o in e)t[o]="function"==typeof e[o]?n(e[o],e):e[o];return t}function o(e,n){e.length=0;for(var t=0,o=n.length;o>t;t++)e[t]=n[t];return e}function a(){function e(e){return M[e]||String.fromCharCode(e)}function n(e){s.mouse.ox=s.mouse.x,s.mouse.oy=s.mouse.y,s.mouse.x=e.x,s.mouse.y=e.y,s.mouse.dx=s.mouse.x-s.mouse.ox,s.mouse.dy=s.mouse.y-s.mouse.oy}function a(e){var n,o=t(e);o.original=e;for(var a=s.canvas,u=0,i=0;a;a=a.offsetParent)u+=a.offsetLeft,i+=a.offsetTop;if(o.touches&&o.touches.length)for(var r,c=o.touches.length-1;c>=0;c--)r=o.touches[c],r.x=r.pageX-u,r.y=r.pageY-i,n=A[c]||r,r.dx=r.x-n.x,r.dy=r.y-n.x,r.ox=n.x,r.oy=n.y,A[c]=t(r);else o.x=o.pageX-u,o.y=o.pageY-i,n=A.mouse||o,o.dx=o.x-n.x,o.dy=o.y-n.y,o.ox=n.x,o.oy=n.y,A.mouse=o;return o}function u(e){e.preventDefault(),e=a(e),o(s.touches,e.touches),n(s.touches[0]),s.touchstart&&s.touchstart(e),s.mousedown&&s.mousedown(e)}function r(e){e=a(e),o(s.touches,e.touches),n(s.touches[0]),s.touchmove&&s.touchmove(e),s.mousemove&&s.mousemove(e)}function c(e){if(e=a(e),e.touches.length)for(var n in A)e.touches[n]||delete A[n];else A={};s.touchend&&s.touchend(e),s.mouseup&&s.mouseup(e)}function m(e){e=a(e),s.mouseover&&s.mouseover(e)}function d(e){e=a(e),s.dragging||(x(s.canvas,"mousemove",h),x(s.canvas,"mouseup",v),y(document,"mousemove",h),y(document,"mouseup",v),s.dragging=!0),o(s.touches,[e]),s.touchstart&&s.touchstart(e),s.mousedown&&s.mousedown(e)}function h(e){e=a(e),n(e),o(s.touches,[e]),s.touchmove&&s.touchmove(e),s.mousemove&&s.mousemove(e)}function f(e){e=a(e),s.mouseout&&s.mouseout(e)}function v(e){e=a(e),s.dragging&&(x(document,"mousemove",h),x(document,"mouseup",v),y(s.canvas,"mousemove",h),y(s.canvas,"mouseup",v),s.dragging=!1),delete A.mouse,s.touchend&&s.touchend(e),s.mouseup&&s.mouseup(e)}function w(e){e=a(e),s.click&&s.click(e)}function l(n){s.keys[e(n.keyCode)]=!0,s.keys[n.keyCode]=!0,s.keydown&&s.keydown(n)}function g(n){s.keys[e(n.keyCode)]=!1,s.keys[n.keyCode]=!1,s.keyup&&s.keyup(n)}var M={8:"BACKSPACE",9:"TAB",13:"ENTER",16:"SHIFT",27:"ESCAPE",32:"SPACE",37:"LEFT",38:"UP",39:"RIGHT",40:"DOWN"};for(var k in M)p.keys[M[k]]=!1;var A={};y(s.canvas,"touchstart",u),y(s.canvas,"touchmove",r),y(s.canvas,"touchend",c),y(s.canvas,"mouseover",m),y(s.canvas,"mousedown",d),y(s.canvas,"mousemove",h),y(s.canvas,"mouseout",f),y(s.canvas,"mouseup",v),y(s.canvas,"click",w),y(document,"keydown",l),y(document,"keyup",g),y(window,"resize",i)}function u(){if(!h){var e=Date.now();s.dt=e-s.now,s.millis+=s.dt,s.now=e,s.update&&s.update(s.dt),s.autoclear&&s.clear(),s.draw&&s.draw(s)}h=++h%s.interval,f=requestAnimationFrame(u)}function i(){if(s.autoresize){var e=s.type===d?s.style:s.canvas;s.fullscreen?(s.height=e.height=window.innerHeight,s.width=e.width=window.innerWidth):(e.height=s.height,e.width=s.width),s.resize&&s.resize()}}var s,r=0,c="canvas",m="web-gl",d="dom",h=0,f=-1,v={},w=[],l={fullscreen:!0,autostart:!0,autoclear:!0,autopause:!0,autoresize:!0,container:document.body,interval:1,type:c},g={PI:Math.PI,TWO_PI:2*Math.PI,HALF_PI:Math.PI/2,QUARTER_PI:Math.PI/4,abs:Math.abs,acos:Math.acos,asin:Math.asin,atan2:Math.atan2,atan:Math.atan,ceil:Math.ceil,cos:Math.cos,exp:Math.exp,floor:Math.floor,log:Math.log,max:Math.max,min:Math.min,pow:Math.pow,round:Math.round,sin:Math.sin,sqrt:Math.sqrt,tan:Math.tan,random:function(e,n){return e&&"number"==typeof e.length&&e.length?e[Math.floor(Math.random()*e.length)]:("number"!=typeof n&&(n=e||1,e=0),e+Math.random()*(n-e))}},p={millis:0,now:0/0,dt:0/0,keys:{},mouse:{x:0,y:0,ox:0,oy:0,dx:0,dy:0},touches:[],initialized:!1,dragging:!1,running:!1,start:function(){s.running||(s.setup&&!s.initialized&&(s.autopause&&(y(window,"focus",s.start),y(window,"blur",s.stop)),s.setup()),s.initialized=!0,s.running=!0,s.now=Date.now(),u())},stop:function(){cancelAnimationFrame(f),s.running=!1},toggle:function(){(s.running?s.stop:s.start)()},clear:function(){s.canvas&&(s.canvas.width=s.canvas.width)},destroy:function(){var e,n,t,o,a,u;w.splice(w.indexOf(s),1),s.stop();for(n in v){for(t=v[n],a=0,u=t.length;u>a;a++)e=t[a],x(e.el,n,e.fn);delete v[n]}s.container.removeChild(s.canvas);for(o in s)s.hasOwnProperty(o)&&delete s[o]}},y=function(){function e(e,n,t){v[n]||(v[n]=[]),v[n].push({el:e,fn:t})}return window.addEventListener?function(n,t,o){n.addEventListener(t,o,!1),e(n,t,o)}:window.attachEvent?function(n,t,o){n.attachEvent("on"+t,o),e(n,t,o)}:function(n,t,o){n["on"+t]=o,e(n,t,o)}}(),x=function(){function e(e,n,t){if(v[n])for(var o,a=v[n].length-1;a>=0;a--)o=v[n][a],o.el===e&&o.fn===t&&v[n].splice(a,1)}return window.removeEventListener?function(n,t,o){n.removeEventListener(t,o,!1),e(n,t,o)}:window.detachEvent?function(n,t,o){n.detachEvent("on"+t,o),e(n,t,o)}:(el["on"+ev]=null,e(el,ev,fn),void 0)}();return{CANVAS:c,WEB_GL:m,DOM:d,instances:w,create:e}}();Date.now||(Date.now=function(){return+new Date}),function(){for(var e=0,n=["ms","moz","webkit","o"],t=0;n.length>t&&!window.requestAnimationFrame;++t)window.requestAnimationFrame=window[n[t]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[n[t]+"CancelAnimationFrame"]||window[n[t]+"CancelRequestAnimationFrame"];window.requestAnimationFrame||(window.requestAnimationFrame=function(n){var t=Date.now(),o=Math.max(0,16-(t-e)),a=window.setTimeout(function(){n(t+o)},o);return e=t+o,a}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(e){clearTimeout(e)})}();
    </script>
    <script>

      	$(function() {

        var settings = {
          interactive: false,
          darkTheme: false,
          headRadius: 32,
          thickness: 52,
          tentacles: 8,
          friction: 0.09,
          gravity: 0.15,
          colour: { h:0.5, s:0.4, v:0.85 },
          length: 18,
          pulse: true,
          wind: -0.42
        };

        var utils = {

          curveThroughPoints: function( points, ctx ) {

            var i, n, a, b, x, y;

            for ( i = 1, n = points.length - 2; i < n; i++ ) {

              a = points[i];
              b = points[i + 1];

              x = ( a.x + b.x ) * 0.5;
              y = ( a.y + b.y ) * 0.5;

              ctx.quadraticCurveTo( a.x, a.y, x, y );
            }

            a = points[i];
            b = points[i + 1];

            ctx.quadraticCurveTo( a.x, a.y, b.x, b.y );
          }
        };

        var Node = function( x, y ) {

          this.x = this.ox = x || 0.0;
          this.y = this.oy = y || 0.0;

          this.vx = 0.0;
          this.vy = 0.0;
        };

        var Tentacle = function( options ) {

          this.length = options.length || 10;
          this.radius = options.radius || 10;
          this.spacing = options.spacing || 20;
          this.friction = options.friction || 0.8;
          this.shade = random( 0.95, 1.1 );

          this.nodes = [];
          this.outer = [];
          this.inner = [];
          this.theta = [];

          for ( var i = 0; i < this.length; i++ ) {
            this.nodes.push( new Node() );
          }
        };

        Tentacle.prototype = {

          move: function( x, y, instant ) {

            this.nodes[0].x = x;
            this.nodes[0].y = y;

            if ( instant ) {

              var i, node;

              for ( i = 1; i < this.length; i++ ) {

                node = this.nodes[i];
                node.x = x;
                node.y = y;
              }
            }
          },

          update: function() {

            var i, n, s, c, dx, dy, da, px, py, node, prev = this.nodes[0];
            var radius = this.radius * settings.thickness;
            var step = radius / this.length;

            for ( i = 1, j = 0; i < this.length; i++, j++ ) {

              node = this.nodes[i];

              node.x += node.vx;
              node.y += node.vy;

              dx = prev.x - node.x;
              dy = prev.y - node.y;
              da = Math.atan2( dy, dx );

              px = node.x + cos( da ) * this.spacing * settings.length;
              py = node.y + sin( da ) * this.spacing * settings.length;

              node.x = prev.x - ( px - node.x );
              node.y = prev.y - ( py - node.y );

              node.vx = node.x - node.ox;
              node.vy = node.y - node.oy;

              node.vx *= this.friction * (1 - settings.friction);
              node.vy *= this.friction * (1 - settings.friction);

              node.vx += settings.wind;
              node.vy += settings.gravity;

              node.ox = node.x;
              node.oy = node.y;

              s = sin( da + HALF_PI );
              c = cos( da + HALF_PI );

              this.outer[j] = {
                x: prev.x + c * radius,
                y: prev.y + s * radius
              };

              this.inner[j] = {
                x: prev.x - c * radius,
                y: prev.y - s * radius
              };

              this.theta[j] = da;

              radius -= step;

              prev = node;
            }
          },

          draw: function( ctx ) {

            var h, s, v, e;

            s = this.outer[0];
            e = this.inner[0];

            ctx.beginPath();
            ctx.moveTo( s.x, s.y );
            utils.curveThroughPoints( this.outer, ctx );
            utils.curveThroughPoints( this.inner.reverse(), ctx );
            ctx.lineTo( e.x, e.y );
            ctx.closePath();

            h = settings.colour.h * this.shade;
            s = settings.colour.s * 100 * this.shade;
            v = settings.colour.v * 100 * this.shade;

            ctx.fillStyle = 'hsl(' + h + ',' + s + '%,' + v + '%)';
            ctx.fill();

            if ( settings.thickness > 2 ) {

              v += settings.darkTheme ? -4 : 4;

              ctx.strokeStyle = 'hsl(' + h + ',' + s + '%,' + v + '%)';
              ctx.lineWidth = 4;
              ctx.stroke();
            }
          }
        };

        var demo = true;
        var ease = 0.92;
        var modified = false;
        var radius = settings.headRadius;
        var tentacles = [];
        var center = { x:0, y:0 };

        var sketch = Sketch.create({

          container: document.getElementById( 'container' ),

          setup: function() {

            center.x = this.width / 2;
            center.y = this.height / 2;

            var tentacle;

            for ( var i = 0; i < 100; i++ ) {

              tentacle = new Tentacle({
                length: random( 32, 24 ),
                radius: random( 0.6, 0.7 ),
                spacing: random( 0.75, 0.89 ),
                friction: random( 0.9, 0.96 )
              });

              tentacle.move( center.x, center.y, true );
              tentacles.push( tentacle );
            }
          },

          update: function() {

            var t, cx, cy, pulse, touch;

            t = this.millis * 0.001;

            if ( settings.pulse ) {

              pulse = pow( sin( t * PI ), 3 );
              radius = settings.headRadius * 0.1 + settings.headRadius * 0.1 * pulse;
            }

            if ( settings.interactive ) {

              ease += ( 0.19205 - ease ) * 0.1995;

              touch = this.touches[0] || this.mouse;

              center.x += ( touch.x - center.x ) * ease;
              center.y += ( touch.y - center.y ) * ease;

            } else {

              t = this.millis/8;
              cx = this.width * 0.5;
              cy = this.height * 0.7;

              center.x = cx + sin( t * 0.002 ) * cos( t * 0.00004005 ) * cx/2 * 0.90125;
              center.y = cy + sin( t * 0.0023 ) * tan( sin( t * 0.0009 ) * 0.85 ) * cy * 0.24;
            }

            var px, py, theta, tentacle;
            var step = TWO_PI / settings.tentacles;

            for ( var i = 0, n = settings.tentacles; i < n; i++ ) {

              tentacle = tentacles[i];

              theta = i * step;

              px = cos( theta*i*(.339*(step%3))*i*step*9*step%3 ) * radius+(3*i);
              py = sin( theta*i*step ) * radius+(-3*i*9*step%3);

              tentacle.move( center.x + px, center.y + py );
              tentacle.update();
            }
          },

          draw: function() {

            var h = settings.colour.h * 0.95;
            var s = settings.colour.s * 100 * 0.95;
            var v = settings.colour.v * 100 * 0.95;
            var w = v + ( settings.darkTheme ? -10 : 10 );

            this.beginPath();
            this.arc( center.x, center.y, radius + settings.thickness, 0, TWO_PI );
            this.lineWidth = settings.headRadius * 0.3;
            this.globalAlpha = 0.2;
            this.strokeStyle = 'hsl(' + h + ',' + s + '%,' + w + '%)';
            this.stroke();

            this.globalAlpha = 1.0;

            for ( var i = 0, n = settings.tentacles; i < n; i++ ) {
              tentacles[i].draw( this );
            }

            this.beginPath();
            this.arc( center.x, center.y, radius + settings.thickness, 0, TWO_PI );
            this.fillStyle = 'hsl(' + h + ',' + s + '%,' + v + '%)';
            this.fill();
          },

          mousedown: function() {

            if ( demo ) {

              demo = false;
              settings.interactive = true;
          //    interactiveGUI.updateDisplay();

              if ( !modified ) {
                settings.length = 60;
                settings.gravity = 0.001;
                settings.wind = 0.09;
              }
            }
          },

          save: function() {
            window.open( this.canvas.toDataURL(), 'tentacles', "top=20,left=20,width=" + this.width + ",height=" + this.height );
          }
        });

        function onSettingsChanged() {
          modified = true;
        }

        function onThemeChanged( dark ) {

          settings.colour.h = 0;
          settings.colour.s = 0;
          settings.colour.v = dark ? 0.8 : 0.1;

          document.body.className = dark ? 'dark' : '';

          colourGUI.updateDisplay();
        }
      /*
        var gui = new dat.GUI();
        gui.add( settings, 'headRadius' ).min( 0.0 ).max( 100.0 ).onChange( onSettingsChanged );
        gui.add( settings, 'tentacles' ).min( 1 ).max( 100 ).onChange( onSettingsChanged );
        gui.add( settings, 'thickness' ).min( 24.0 ).max( 12.0 ).onChange( onSettingsChanged );
        gui.add( settings, 'length' ).min( 96.0 ).max( 98.0 ).onChange( onSettingsChanged );
        gui.add( settings, 'gravity' ).min( -3.0 ).max( 3.0 ).onChange( onSettingsChanged );
        gui.add( settings, 'wind' ).min( -3.0 ).max( 3.0 ).onChange( onSettingsChanged );
        gui.add( settings, 'friction' ).min( 0.0 ).max( 1.0 ).onChange( onSettingsChanged );

        var colourGUI = gui.addColor( settings, 'colour' );
        gui.add( settings, 'darkTheme' ).onChange( onThemeChanged );
        gui.add( settings, 'pulse' );

        var interactiveGUI = gui.add( settings, 'interactive' );
        gui.add( sketch, 'autoclear' );
        gui.add( sketch, 'save' );
        gui.close();

        onThemeChanged( true );'
        */

      });

    </script>
  </body>
</html>
